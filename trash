pip install dash-bootstrap-components

'''import pandas as pd 
import plotly.express as px
from dash import Dash, html, dcc, callback
from dash.dependencies import Input, Output

# Read the CSV file
df = pd.read_csv("ports.csv")

# Initialize the Dash app
app = Dash(__name__)

# Create a dropdown options list for countries
country_options = [{'label': country, 'value': country} for country in df['country'].unique()]

# Define the layout of the dashboard
app.layout = html.Div([
    html.H1("Port Level Data - US Gulf", style={'margin-top': '20px', 'text-align': 'center'}),
    html.Div([
        dcc.Dropdown(
            id='country-dropdown',
            options=country_options,
            value=None,
            placeholder="Select a country"
        )
    ], style={'width': '30%', 'display': 'inline-block'}),
    html.Div([
        dcc.Dropdown(
            id='port-dropdown',
            placeholder="Select a port"
        )
    ], style={'width': '30%', 'display': 'inline-block'}),
    html.Div([
        html.Div([
            dcc.Graph(
                id='map'
            )
        ], style={'width': '100%', 'display': 'inline-block'}),
        html.Div([
            html.Table(
                id='table-info',
                style={'margin-top': '20px'}
            )
        ], style={'width': '100%', 'display': 'inline-block'})
    ])
])

# Define callback to update the port dropdown options based on selected country
@app.callback(
    Output('port-dropdown', 'options'),
    [Input('country-dropdown', 'value')]
)
def update_port_dropdown_options(selected_country):
    if selected_country:
        ports = df[df['country'] == selected_country]['name'].unique()
        port_options = [{'label': port, 'value': port} for port in ports]
        return port_options
    else:
        return []

# Define callback to update the map and table based on selected country and port
@app.callback(
    [Output('map', 'figure'),
     Output('table-info', 'children')],
    [Input('country-dropdown', 'value'),
     Input('port-dropdown', 'value')]
)
def update_map_and_table(selected_country, selected_port):
    filtered_df = df

    if selected_country:
        filtered_df = filtered_df[df['country'] == selected_country]

    if selected_port:
        filtered_df = filtered_df[df['name'] == selected_port]

    # Create map figure
    map_figure = px.scatter_mapbox(
        filtered_df,
        lon=filtered_df['lon'],
        lat=filtered_df['lat'],
        zoom=3,
        width=800,
        height=500,
        text=filtered_df['name'],
        title='Port Level Data - US Gulf'
    ).update_layout(
        mapbox_style="open-street-map",
        margin={"r": 0, "t": 10, "l": 0, "b": 10}
    )

    # Create table with port_id, name, region, port capacity
    table_columns = ['port_id', 'name', 'region', 'Port Capacity (Mcm)']
    table_data = filtered_df[table_columns]

    table = html.Table(
        # Header
        [html.Tr([html.Th(col) for col in table_data.columns])] +

        # Body
        [html.Tr([html.Td(table_data.iloc[i][col]) for col in table_data.columns]) for i in range(len(table_data))]
    )

    return map_figure, table

# Run the app
if __name__ == '__main__':
    app.run_server(debug=True)'''


import pandas as pd 
import plotly.express as px
from dash import Dash, html, dcc
from dash.dependencies import Input, Output

# Read the CSV files for IMO and ports data
ship_data = pd.read_csv("imo_tracking.csv")  
ports_data = pd.read_csv("ports.csv")  
regions = pd.read_csv("regions.csv")
yy_ship_count = pd.read_csv("yy_ship_count.csv")

# Initialize the Dash app
app = Dash(__name__)

# Define the layout of the dashboard
app.layout = html.Div([
    html.H1("IMO and Ports Location Data", style={'text-align': 'center'}),
    html.Div([
        dcc.Graph(
            id='map'
        )
    ])
])

# Define callback to update the map with IMO and Ports locations
@app.callback(
    Output('map', 'figure'),
    [Input('map', 'id')]  # Dummy callback to trigger the initial map creation
)
def update_map(_):
    # Create map figure for IMO locations
    imo_map = px.scatter_mapbox(
        ship_data,
        lat='lat',
        lon='lon',
        zoom=2,
        width=800,
        height=500,
        text='name',  # Replace with appropriate text column name from IMO data
        title='IMO and Ports Locations'
    )
    
    # Add ports data to the map as a separate trace
    ports_map = px.scatter_mapbox(
        ports_data,
        lat='lat',
        lon='lon',
        zoom=2,
        width=800,
        height=500,
        text='name',  # Replace with appropriate text column name from Ports data
        title='IMO and Ports Locations'
    )

    # Update marker properties for ports
    ports_map.update_traces(marker=dict(size=10, color='black'))  # Set marker properties for ports

    # Add ports trace to the IMO map
    for data in ports_map.data:
        imo_map.add_trace(data)

    # Update layout
    imo_map.update_layout(
        mapbox_style="open-street-map",
        margin={"r": 0, "t": 0, "l": 0, "b": 0}
    )

    return imo_map

# Run the app
if __name__ == '__main__':
    app.run_server(debug=True)


"""import pandas as pd
import plotly.express as px
import dash
from dash import html, dcc
from dash.dependencies import Input, Output
import dash_bootstrap_components as dbc

# Read the CSV files for IMO and ports data
ship_data = pd.read_csv("imo_tracking.csv")
ports_data = pd.read_csv("ports.csv")
regions = pd.read_csv("regions.csv")
yy_ship_count = pd.read_csv("yy_ship_count.csv")

app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Get unique values for the source region dropdown
source_regions = ship_data['source_region'].unique()

app.layout = dbc.Container([
    html.H1("IMO and Ports Location Data", style={'text-align': 'center'}),
    dbc.Row([
        dbc.Col(
            html.Div([
                dcc.Input(
                    id='imo-search',
                    type='text',
                    placeholder='Enter IMO number...',
                    value='',  # Initial value of the search box
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Regions"),
                dcc.Dropdown(
                    id='source-region-dropdown',
                    options=[{'label': 'Select All', 'value': 'selectall'},
                             {'label': 'Deselect All', 'value': 'deselectall'}] + [{'label': region, 'value': region} for region in source_regions],
                    value=['selectall'],  # Set default value as 'selectall'
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                )
            ]),
            width=3  # Left side column width
        ),
        dbc.Col(
            html.Div([
                dcc.Graph(
                    id='map'
                )
            ]),
            width=8  # Right side column width
        )
    ], justify="left")  # Center-aligns the row
])

@app.callback(
    Output('map', 'figure'),
    [Input('imo-search', 'value'),
     Input('source-region-dropdown', 'value')]
)
def update_map(imo_number, selected_regions):
    # Handle 'selectall' and 'deselectall' options for source regions
    if 'selectall' in selected_regions:
        filtered_ship_data = ship_data
        selected_regions.remove('selectall')
    elif 'deselectall' in selected_regions:
        filtered_ship_data = pd.DataFrame()  # Empty DataFrame when 'deselectall' is selected
        selected_regions.remove('deselectall')
    else:
        filtered_ship_data = ship_data[ship_data['source_region'].isin(selected_regions)]

    # Create a color scale based on unique values in the "source_region" column
    color_discrete_map = px.colors.qualitative.Dark24[:len(filtered_ship_data['source_region'].unique())]

    imo_map = px.scatter_mapbox(
        filtered_ship_data,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        text='name',
        color='source_region',  # Assign different colors based on 'source_region'
        color_discrete_sequence=color_discrete_map,  # Apply unique colors to each 'source_region'
        title=f'IMO and Ports Locations for {selected_regions if selected_regions else "All"}'
    )

    ports_map = px.scatter_mapbox(
        ports_data,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        text='name',
        title='IMO and Ports Locations'
    )

    ports_map.update_traces(marker=dict(size=10, color='black'))

    for data in ports_map.data:
        imo_map.add_trace(data)

    imo_map.update_layout(
        mapbox_style="open-street-map",
        margin={"r": 0, "t": 0, "l": 0, "b": 0}
    )

    return imo_map

if __name__ == '__main__':
    app.run_server(debug=True)
"""
3
"""import pandas as pd
import plotly.express as px
import dash
from dash import html, dcc
from dash.dependencies import Input, Output
import dash_bootstrap_components as dbc

# Read the CSV files for IMO and ports data
ship_data = pd.read_csv("imo_tracking.csv")
ports_data = pd.read_csv("ports.csv")
regions = pd.read_csv("regions.csv")
yy_ship_count = pd.read_csv("yy_ship_count.csv")

combined_data = pd.merge(ship_data, yy_ship_count, on='imo', how='left')

app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Get unique values for the source region dropdown
source_regions = ship_data['source_region'].unique()

app.layout = dbc.Container([
    html.H1("IMO and Ports Location Data", style={'text-align': 'center'}),
    dbc.Row([
        dbc.Col(
            html.Div([
                dcc.Input(
                    id='imo-search',
                    type='text',
                    placeholder='Enter IMO number...',
                    value='',  # Initial value of the search box
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Regions"),
                dcc.Dropdown(
                    id='source-region-dropdown',
                    options=[{'label': 'Select All', 'value': 'selectall'},
                             ] + [{'label': region, 'value': region} for region in source_regions],
                    value=['selectall'],  # Set default value as 'selectall'
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Subregions"),
                dcc.Dropdown(
                    id='source-subregion-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': subregion, 'value': subregion} for subregion in ship_data['source_subregion'].unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),

                html.Label("Ports"),
                dcc.Dropdown(
                    id='source-port-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': port, 'value': port} for port in ship_data['source_port'].unique()],
                    value=[],  # Initial value for port dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                )
            ]),
            width=3  # Left side column width
        ),
        dbc.Col(
            html.Div([
                dcc.Graph(
                    id='map'
                )
            ]),
            width=8  # Right side column width
        )
    ], justify="left")  # Center-aligns the row
])

@app.callback(
    Output('source-subregion-dropdown', 'options'),
    [Input('source-region-dropdown', 'value')]
)
def update_subregion_options(selected_regions):
    if 'selectall' in selected_regions:
        filtered_ship_data = ship_data
        selected_regions.remove('selectall')
    elif 'deselectall' in selected_regions:
        filtered_ship_data = pd.DataFrame()  # Empty DataFrame when 'deselectall' is selected
        selected_regions.remove('deselectall')
    else:
        filtered_ship_data = ship_data[ship_data['source_region'].isin(selected_regions)]

    subregions = filtered_ship_data['source_subregion'].unique()
    return [{'label': subregion, 'value': subregion} for subregion in subregions]

@app.callback(
    Output('source-port-dropdown', 'options'),
    [Input('source-subregion-dropdown', 'value')]
)
def update_port_options(selected_subregions):
    filtered_ship_data = ship_data[ship_data['source_subregion'].isin(selected_subregions)]
    ports = filtered_ship_data['source_port'].unique()
    return [{'label': port, 'value': port} for port in ports]

@app.callback(
    Output('map', 'figure'),
    [Input('imo-search', 'value'),
     Input('source-region-dropdown', 'value'),
     Input('source-subregion-dropdown', 'value'),
     Input('source-port-dropdown', 'value')]
)
def update_map(imo_number, selected_regions, selected_subregions, selected_ports):
    # Filter ship data based on selected regions, subregions, and ports
    filtered_ship_data = ship_data.copy()

    if 'selectall' not in selected_regions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_region'].isin(selected_regions)]

    if selected_subregions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_subregion'].isin(selected_subregions)]

    if selected_ports:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_port'].isin(selected_ports)]

    # Create a color scale based on unique values in the "source_region" column
    color_discrete_map = px.colors.qualitative.Dark24[:len(filtered_ship_data['source_region'].unique())]

    imo_map = px.scatter_mapbox(
        filtered_ship_data,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        text='name',
        color='source_region',  # Assign different colors based on 'source_region'
        color_discrete_sequence=color_discrete_map,  # Apply unique colors to each 'source_region'
        title=f'IMO and Ports Locations for {selected_regions if selected_regions else "All"}'
    )

    ports_map = px.scatter_mapbox(
        ports_data,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        text='name',
        title='IMO and Ports Locations'
    )

    ports_map.update_traces(marker=dict(size=10, color='black'))

    for data in ports_map.data:
        imo_map.add_trace(data)

    imo_map.update_layout(
        mapbox_style="open-street-map",
        margin={"r": 0, "t": 0, "l": 0, "b": 0}
    )

    return imo_map
    # Your existing map update logic here...
    # Remember to filter ship_data based on selected_regions, selected_subregions, and selected_ports

    # Create the updated map based on filtered ship data

    #return updated_map_figure  # Return the updated map figure

if __name__ == '__main__':
    app.run_server(debug=True)
"""

4

'''import pandas as pd
import plotly.express as px
import dash
from dash import html, dcc
from dash.dependencies import Input, Output
import dash_bootstrap_components as dbc

# Read the CSV files for IMO and ports data
ship_data = pd.read_csv("imo_tracking.csv")
ports_data = pd.read_csv("ports.csv")
regions = pd.read_csv("regions.csv")
yy_ship_count = pd.read_csv("yy_ship_count.csv")

combined_data = pd.merge(ship_data, yy_ship_count, on='imo', how='left')

app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Get unique values for the source region dropdown
source_regions = ship_data['source_region'].unique()

app.layout = dbc.Container([
    html.H1("IMO and Ports Location Data", style={'text-align': 'center'}),
    dbc.Row([
        dbc.Col(
            html.Div([
                dcc.Input(
                    id='imo-search',
                    type='text',
                    placeholder='Enter IMO number...',
                    value='',  # Initial value of the search box
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Regions"),
                dcc.Dropdown(
                    id='source-region-dropdown',
                    options=[{'label': 'Select All', 'value': 'selectall'},
                             ] + [{'label': region, 'value': region} for region in source_regions],
                    value=['selectall'],  # Set default value as 'selectall'
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Subregions"),
                dcc.Dropdown(
                    id='source-subregion-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': subregion, 'value': subregion} for subregion in ship_data['source_subregion'].unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),

                html.Label("Ports"),
                dcc.Dropdown(
                    id='source-port-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': port, 'value': port} for port in ship_data['source_port'].unique()],
                    value=[],  # Initial value for port dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                )
            ]),
            width=3  # Left side column width
        ),
        dbc.Col(
            html.Div([
                dcc.Graph(
                    id='map'
                )
            ]),
            width=8  # Right side column width
        )
    ], justify="left")  # Center-aligns the row
])

@app.callback(
    Output('source-subregion-dropdown', 'options'),
    [Input('source-region-dropdown', 'value')]
)
def update_subregion_options(selected_regions):
    if 'selectall' in selected_regions:
        filtered_ship_data = ship_data
        selected_regions.remove('selectall')
    elif 'deselectall' in selected_regions:
        filtered_ship_data = pd.DataFrame()  # Empty DataFrame when 'deselectall' is selected
        selected_regions.remove('deselectall')
    else:
        filtered_ship_data = ship_data[ship_data['source_region'].isin(selected_regions)]

    subregions = filtered_ship_data['source_subregion'].unique()
    return [{'label': subregion, 'value': subregion} for subregion in subregions]

@app.callback(
    Output('source-port-dropdown', 'options'),
    [Input('source-subregion-dropdown', 'value')]
)
def update_port_options(selected_subregions):
    filtered_ship_data = ship_data[ship_data['source_subregion'].isin(selected_subregions)]
    ports = filtered_ship_data['source_port'].unique()
    return [{'label': port, 'value': port} for port in ports]

@app.callback(
    Output('map', 'figure'),
    [Input('imo-search', 'value'),
     Input('source-region-dropdown', 'value'),
     Input('source-subregion-dropdown', 'value'),
     Input('source-port-dropdown', 'value')]
)
def update_map(imo_number, selected_regions, selected_subregions, selected_ports):
    # Filter ship data based on selected regions, subregions, and ports
    filtered_ship_data = combined_data.copy()

    if 'selectall' not in selected_regions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_region'].isin(selected_regions)]

    if selected_subregions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_subregion'].isin(selected_subregions)]

    if selected_ports:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_port'].isin(selected_ports)]

    # Create a color scale based on unique values in the "source_region" column
    color_discrete_map = px.colors.qualitative.Dark24[:len(filtered_ship_data['region'].unique())]

    imo_map = px.scatter_mapbox(
        filtered_ship_data,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        text='name',
        color='region',  # Assign different colors based on 'source_region'
        color_discrete_sequence=color_discrete_map,  # Apply unique colors to each 'source_region'
        title=f'IMO and Ports Locations for {selected_regions if selected_regions else "All"}'
    )

    ports_map = px.scatter_mapbox(
        ports_data,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        text='name',
        title='IMO and Ports Locations'
    )

    ports_map.update_traces(marker=dict(size=10, color='yellow'))

    for data in ports_map.data:
        imo_map.add_trace(data)

    imo_map.update_layout(
        mapbox_style="open-street-map",
        margin={"r": 0, "t": 0, "l": 0, "b": 0}
    )

    return imo_map
    # Your existing map update logic here...
    # Remember to filter ship_data based on selected_regions, selected_subregions, and selected_ports

    # Create the updated map based on filtered ship data

    #return updated_map_figure  # Return the updated map figure

if __name__ == '__main__':
    app.run_server(debug=True)
'''

5

"""import pandas as pd
import plotly.express as px
import dash
from dash import html, dcc
from dash.dependencies import Input, Output
import dash_bootstrap_components as dbc

# Read the CSV files for IMO and ports data
ship_data = pd.read_csv("imo_tracking.csv")
ports_data = pd.read_csv("ports.csv")
regions = pd.read_csv("regions.csv")
yy_ship_count = pd.read_csv("yy_ship_count.csv")

combined_data = pd.merge(ship_data, yy_ship_count, on='imo', how='left')

app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Get unique values for the source region dropdown
source_regions = ship_data['source_region'].unique()

app.layout = dbc.Container([
    html.H1("IMO and Ports Location Data", style={'text-align': 'center'}),
    dbc.Row([
        dbc.Col(
            html.Div([
                html.Label("Search IMO:"),
                dcc.Input(
                    id='imo-search',
                    type='text',
                    placeholder='Enter IMO number...',
                    value='',  # Initial value of the search box
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("include Orgin Regions"),
                dcc.Dropdown(
                    id='source-region-dropdown',
                    options=[{'label': 'Select All', 'value': 'selectall'},
                             ] + [{'label': region, 'value': region} for region in source_regions],
                    value=['selectall'],  # Set default value as 'selectall'
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Select Sub-regions"),
                dcc.Dropdown(
                    id='source-subregion-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': subregion, 'value': subregion} for subregion in ship_data['source_subregion'].unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),

                html.Label("Select Ports"),
                dcc.Dropdown(
                    id='source-port-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': port, 'value': port} for port in ship_data['source_port'].unique()],
                    value=[],  # Initial value for port dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Idle if No Movement in (Days)"),
                dcc.Slider(
                    id='idle-days-slider',
                    min=1,
                    max=5,
                    step=1,
                    value=1,  # Initial value
                    marks={i: str(i) for i in range(1, 6)},  # Display marks for each value
                ),
                html.Label("ship path length in (hours)"),
                dcc.Slider(
                    id='ship-path-slider',
                    min=7,
                    max=72,
                    step=10,
                    value=7,  # Initial value
                    marks={i: str(i) for i in range(7, 73,7)},  # Display marks for each value
                ),
            ]),
            width=3  # Left side column width
        ),
        dbc.Col(
            html.Div([
                dcc.Graph(
                    id='map'
                )
            ]),
            width=8  # Right side column width
        )
    ], justify="left")  # Center-aligns the row
])

@app.callback(
    Output('source-subregion-dropdown', 'options'),
    [Input('source-region-dropdown', 'value')]
)
def update_subregion_options(selected_regions):
    if 'selectall' in selected_regions:
        filtered_ship_data = ship_data
        selected_regions.remove('selectall')
    elif 'deselectall' in selected_regions:
        filtered_ship_data = pd.DataFrame()  # Empty DataFrame when 'deselectall' is selected
        selected_regions.remove('deselectall')
    else:
        filtered_ship_data = ship_data[ship_data['source_region'].isin(selected_regions)]

    subregions = filtered_ship_data['source_subregion'].unique()
    return [{'label': subregion, 'value': subregion} for subregion in subregions]

@app.callback(
    Output('source-port-dropdown', 'options'),
    [Input('source-subregion-dropdown', 'value')]
)
def update_port_options(selected_subregions):
    filtered_ship_data = ship_data[ship_data['source_subregion'].isin(selected_subregions)]
    ports = filtered_ship_data['source_port'].unique()
    return [{'label': port, 'value': port} for port in ports]

@app.callback(
    Output('map', 'figure'),
    [Input('imo-search', 'value'),
     Input('source-region-dropdown', 'value'),
     Input('source-subregion-dropdown', 'value'),
     Input('source-port-dropdown', 'value'),
     Input('idle-days-slider', 'value')]
)
def update_map(imo_number, selected_regions, selected_subregions, selected_ports, idle_days):
    # Filter ship data based on selected regions, subregions, and ports
    filtered_ship_data = combined_data.copy()

    if 'selectall' not in selected_regions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_region'].isin(selected_regions)]

    if selected_subregions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_subregion'].isin(selected_subregions)]

    if selected_ports:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_port'].isin(selected_ports)]

    ship_datas = ship_data.copy()

    if 'selectall' not in selected_regions:
        ship_datas = ship_datas[ship_datas['source_region'].isin(selected_regions)]

    if selected_subregions:
        ship_datas = ship_datas[ship_datas['source_subregion'].isin(selected_subregions)]

    if selected_ports:
        ship_datas = ship_datas[ship_datas['source_port'].isin(selected_ports)]



    # Filter data based on 'imo', 'idle', and 'seen_date' conditions
    ship_datas = ship_datas[
        (ship_datas['imo'] == imo_number) &
        (ship_datas['idle'] == 1) &
        (pd.to_datetime(ship_datas['seen_date']) >= pd.to_datetime('today') - pd.Timedelta(days=idle_days))
    ]

    # Create a color scale based on unique values in the "source_region" column
    color_discrete_map = px.colors.qualitative.Dark24[:len(filtered_ship_data['region'].unique())]

    imo_map = px.scatter_mapbox(
        filtered_ship_data,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        text='name',
        color='region',  # Assign different colors based on 'source_region'
        color_discrete_sequence=color_discrete_map,  # Apply unique colors to each 'source_region'
        title=f'IMO and Ports Locations for {selected_regions if selected_regions else "All"}'
    )

    ports_map = px.scatter_mapbox(
        ports_data,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        text='name',
        title='IMO and Ports Locations'
    )

    ports_map.update_traces(marker=dict(size=10, color='yellow'))

    for data in ports_map.data:
        imo_map.add_trace(data)

    imo_map.update_layout(
        mapbox_style="open-street-map",
        margin={"r": 0, "t": 0, "l": 0, "b": 0}
    )

    return imo_map
    # Your existing map update logic here...
    # Remember to filter ship_data based on selected_regions, selected_subregions, and selected_ports

    # Create the updated map based on filtered ship data

    #return updated_map_figure  # Return the updated map figure

if __name__ == '__main__':
    app.run_server(debug=True)
"""

6

'''import pandas as pd
import plotly.express as px
import dash
from dash import html, dcc
from dash.dependencies import Input, Output
import dash_bootstrap_components as dbc
import plotly.graph_objects as go


# Read the CSV files for IMO and ports data
ship_data = pd.read_csv("imo_tracking.csv")
ports_data = pd.read_csv("ports.csv")
regions = pd.read_csv("regions.csv")
yy_ship_count = pd.read_csv("yy_ship_count.csv")

combined_data = pd.merge(ship_data, yy_ship_count, on='imo', how='left')
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Get unique values for the source region dropdown
source_regions = ship_data['source_region'].unique()

app.layout = dbc.Container([
    html.H1("IMO and Ports Location Data", style={'text-align': 'center'}),
    dbc.Row([
        dbc.Col(
            html.Div([
                dcc.Input(
                    id='imo-search',
                    type='text',
                    placeholder='Enter IMO number...',
                    value='',  # Initial value of the search box
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Regions"),
                dcc.Dropdown(
                    id='source-region-dropdown',
                    options=[{'label': 'Select All', 'value': 'selectall'},
                             {'label': 'Deselect All', 'value': 'deselectall'}] + [{'label': region, 'value': region} for region in source_regions],
                    value=['selectall'],  # Set default value as 'selectall'
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Select Sub-regions"),
                dcc.Dropdown(
                    id='source-subregion-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': subregion, 'value': subregion} for subregion in ship_data['source_subregion'].unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Select Ports"),
                dcc.Dropdown(
                    id='source-port-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': port, 'value': port} for port in ship_data['source_port'].unique()],
                    value=[],  # Initial value for port dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Dest Region"),
                dcc.Dropdown(
                    id='dest-region-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] +[{'label': region, 'value': region} for region in regions['region'].unique()],
                    value=[],  # Initial value for region dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),

                html.Label("Dest Sub-region"),
                dcc.Dropdown(
                    id='dest-subregion-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': subregion, 'value': subregion} for subregion in combined_data['subregion'].dropna().unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),

                html.Label("Dest port"),
                dcc.Dropdown(
                    id='dest-port-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': port_name, 'value': port_name} for port_name in combined_data['port_name'].dropna().unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                dbc.Label("Idle Ships"),
                dbc.Checklist(
                    options=[
                        {"label": "idle", "value": 1},
                        {"label": "active", "value": 0},
                    ],
                    
                    value=[],
                    id="checklist-idle-input",
                    inline=True,
                ),
                dbc.Label("empty full"),
                dbc.Checklist(
                    options=[
                        {"label": "empty", "value": 1},
                        {"label": "full", "value": 0},
                    ],
                    
                    value=[],
                    id="checklist-emptyfull-input",
                    inline=True,
                ),

                          
   
                
                # Output for displaying the filtered data
           
            ]),
            width=3  # Left side column width
        ),
        dbc.Col(
            html.Div([
                dcc.Graph(
                    id='map'
                )
            ]),
            width=8  # Right side column width
        )
    ], justify="left")  # Center-aligns the row
])    
@app.callback(
    Output('source-subregion-dropdown', 'options'),
    [Input('source-region-dropdown', 'value')]
)
def update_subregion_options(selected_regions):
    if 'selectall' in selected_regions:
        filtered_ship_data = ship_data
        selected_regions.remove('selectall')
    elif 'deselectall' in selected_regions:
        filtered_ship_data = pd.DataFrame()  # Empty DataFrame when 'deselectall' is selected
        selected_regions.remove('deselectall')
    else:
        filtered_ship_data = ship_data[ship_data['source_region'].isin(selected_regions)]

    subregions = filtered_ship_data['source_subregion'].unique()
    return [{'label': subregion, 'value': subregion} for subregion in subregions]

@app.callback(
    Output('source-port-dropdown', 'options'),
    [Input('source-subregion-dropdown', 'value')]
)
def update_port_options(selected_subregions):
    filtered_ship_data = ship_data[ship_data['source_subregion'].isin(selected_subregions)]
    ports = filtered_ship_data['source_port'].unique()
    return [{'label': port, 'value': port} for port in ports]



@app.callback(
    Output('dest-subregion-dropdown', 'options'),
    [Input('dest-region-dropdown', 'value')]
)
def update_dest_subregion_options(selected_dest_regions):
    if 'selectall' in selected_dest_regions:
        subregions = combined_data['subregion'].dropna().unique()
        return [{'label': subregion, 'value': subregion} for subregion in subregions]

    elif 'deselectall' in selected_dest_regions:
        return []

    else:
        filtered_combined_data = combined_data[combined_data['region'].isin(selected_dest_regions)]
        subregions = filtered_combined_data['subregion'].dropna().unique()
        return [{'label': subregion, 'value': subregion} for subregion in subregions]


@app.callback(
    Output('dest-port-dropdown', 'options'),
    [Input('dest-subregion-dropdown', 'value')]
)
def update_dest_port_options(selected_dest_subregions):
    if 'selectall' in selected_dest_subregions:
        filtered_combined_data = combined_data
        selected_dest_subregions.remove('selectall')
    elif 'deselectall' in selected_dest_subregions:
        filtered_combined_data = pd.DataFrame()  # Empty DataFrame when 'deselectall' is selected
        selected_dest_subregions.remove('deselectall')
    else:
        filtered_combined_data = combined_data[combined_data['subregion'].isin(selected_dest_subregions)]

    ports = filtered_combined_data['port_name'].dropna().unique()
    return [{'label': port, 'value': port} for port in ports]





@app.callback(
    Output('map', 'figure'),
    [Input('imo-search', 'value'),
     Input('source-region-dropdown', 'value'),
     Input('source-subregion-dropdown', 'value'),
     Input('source-port-dropdown', 'value'),
     Input('dest-region-dropdown', 'value'),
     Input('dest-subregion-dropdown', 'value'),
     Input('dest-port-dropdown', 'value'),
     Input('checklist-idle-input', 'value'),
     Input('checklist-emptyfull-input', 'value'),
     ]
)
def update_map(imo_number, selected_regions,selected_subregions,selected_ports,dest_regions,dest_subregions,dest_ports,selected_idle_status,selected_emptyfull_status):
    filtered_ship_data = combined_data  # Initialize with the combined data

    #print(combined_data.columns.tolist())
    #print(filtered_ship_data['idle_y'].head())

     # Filter based on selected idle status
    #if selected_idle_status:
    #    filtered_ship_data = combined_data[combined_data['idle'].isin(selected_idle_status)]
    if selected_emptyfull_status:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['empty_full'].isin(selected_emptyfull_status)]

    if selected_idle_status:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['idle_y'].isin(selected_idle_status)]


    if dest_ports and 'selectall' not in dest_ports:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['port_name'].isin(dest_ports)]


    if dest_regions and 'selectall' not in dest_regions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['region'].isin(dest_regions)]

    if dest_subregions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['subregion'].isin(dest_subregions)]

    # Filter data based on selected regions
    if selected_regions and 'selectall' not in selected_regions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_region'].isin(selected_regions)]

    # Filter data based on sub regions
    if selected_subregions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_subregion'].isin(selected_subregions)]

    # Filter data based on IMO number if provided
    if imo_number and imo_number.isdigit():
        imo_number = int(imo_number)
        filtered_ship_data = filtered_ship_data[filtered_ship_data['imo'] == imo_number]

    if selected_ports:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_port'].isin(selected_ports)]
    
    


    # Convert 'seen_date' column to datetime
    filtered_ship_data['seen_date'] = pd.to_datetime(filtered_ship_data['seen_date'])

    # Group by 'imo' and get the latest 'seen_date' for each IMO
    latest_dates = filtered_ship_data.groupby('imo')['seen_date'].max().reset_index()

    # Merge to get the lat/lon corresponding to the latest 'seen_date'
    latest_locations = pd.merge(latest_dates, filtered_ship_data, on=['imo', 'seen_date'], how='left')

    # Create a column 'hours_since_latest' representing the difference in hours from the latest 'seen_date'
    latest_locations['hours_since_latest'] = (latest_locations['seen_date'].max() - latest_locations['seen_date']).dt.total_seconds() / 3600

    # Create a new column 'size' to differentiate between latest and previous locations
    latest_locations['size'] = 10  # Default size for previous locations
    #latest_locations.loc[latest_locations['hours_since_latest'] == 0, 'size'] = 20  # Larger size for the latest location
 
    # Plot the map
    imo_map = px.scatter_mapbox(
        latest_locations,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        
        title=f'IMO and Ports Locations for {selected_regions if selected_regions else "All"}',
        color='region'
    )

    

    # Update marker sizes for differentiating latest and previous locations
    imo_map.update_traces(marker=dict(size=latest_locations['size']))

    imo_map.update_layout(
        mapbox_style="open-street-map",
        margin={"r": 0, "t": 0, "l": 0, "b": 0}
    )

    # Add ports data to the map
    ports_map = px.scatter_mapbox(
        ports_data,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        text='name',
        title='IMO and Ports Locations'
    )

    ports_map.update_traces(marker=dict(size=10, color='grey'))

    for data in ports_map.data:
        imo_map.add_trace(data)

    imo_map.update_layout(
        mapbox_style="open-street-map",
        margin={"r": 0, "t": 0, "l": 0, "b": 0}
    )

    return imo_map

#fig.show()
if __name__ == '__main__':
    app.run_server(debug=True)


'''

7
#completed all dropbox and maxfull draft slider

'''import pandas as pd
import plotly.express as px
import dash
from dash import html, dcc
from dash.dependencies import Input, Output
import dash_bootstrap_components as dbc
import plotly.graph_objects as go


# Read the CSV files for IMO and ports data
ship_data = pd.read_csv("imo_tracking.csv")
ports_data = pd.read_csv("ports.csv")
regions = pd.read_csv("regions.csv")
yy_ship_count = pd.read_csv("yy_ship_count.csv")

combined_data = pd.merge(ship_data, yy_ship_count, on='imo', how='left')
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Get unique values for the source region dropdown
source_regions = ship_data['source_region'].unique()

app.layout = dbc.Container([
    html.H1("IMO and Ports Location Data", style={'text-align': 'center'}),
    dbc.Row([
        dbc.Col(
            html.Div([
                dcc.Input(
                    id='imo-search',
                    type='text',
                    placeholder='Enter IMO number...',
                    value='',  # Initial value of the search box
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Regions"),
                dcc.Dropdown(
                    id='source-region-dropdown',
                    options=[{'label': 'Select All', 'value': 'selectall'},
                             {'label': 'Deselect All', 'value': 'deselectall'}] + [{'label': region, 'value': region} for region in source_regions],
                    value=['selectall'],  # Set default value as 'selectall'
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Select Sub-regions"),
                dcc.Dropdown(
                    id='source-subregion-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': subregion, 'value': subregion} for subregion in ship_data['source_subregion'].unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Select Ports"),
                dcc.Dropdown(
                    id='source-port-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': port, 'value': port} for port in ship_data['source_port'].unique()],
                    value=[],  # Initial value for port dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Dest Region"),
                dcc.Dropdown(
                    id='dest-region-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] +[{'label': region, 'value': region} for region in regions['region'].unique()],
                    value=[],  # Initial value for region dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),

                html.Label("Dest Sub-region"),
                dcc.Dropdown(
                    id='dest-subregion-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': subregion, 'value': subregion} for subregion in combined_data['subregion'].dropna().unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),

                html.Label("Dest port"),
                dcc.Dropdown(
                    id='dest-port-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': port_name, 'value': port_name} for port_name in combined_data['port_name'].dropna().unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                dbc.Label("Idle Ships"),
                dbc.Checklist(
                    options=[
                        {"label": "idle", "value": 1},
                        {"label": "active", "value": 0},
                    ],
                    
                    value=[],
                    id="checklist-idle-input",
                    inline=True,
                ),
                dbc.Label("empty full"),
                dbc.Checklist(
                    options=[
                        {"label": "empty", "value": 1},
                        {"label": "full", "value": 0},
                    ],
                    
                    value=[],
                    id="checklist-emptyfull-input",
                    inline=True,
                ),
                dbc.Label("Max Full Draft (meter)"),
                dcc.Slider(
                    id='fulldraft-slider',
                    min=11,
                    max=14,
                    step=0.2,
                    marks={value: str(value) for value in range(11, 15) if value % 1 == 0},

                    value=11,  # Initial value
                ),                

                          
   
                
                # Output for displaying the filtered data
           
            ]),
            width=3  # Left side column width
        ),
        dbc.Col(
            html.Div([
                dcc.Graph(
                    id='map'
                )
            ]),
            width=8  # Right side column width
        )
    ], justify="left")  # Center-aligns the row
])    
@app.callback(
    Output('source-subregion-dropdown', 'options'),
    [Input('source-region-dropdown', 'value')]
)
def update_subregion_options(selected_regions):
    if 'selectall' in selected_regions:
        filtered_ship_data = ship_data
        selected_regions.remove('selectall')
    elif 'deselectall' in selected_regions:
        filtered_ship_data = pd.DataFrame()  # Empty DataFrame when 'deselectall' is selected
        selected_regions.remove('deselectall')
    else:
        filtered_ship_data = ship_data[ship_data['source_region'].isin(selected_regions)]

    subregions = filtered_ship_data['source_subregion'].unique()
    return [{'label': subregion, 'value': subregion} for subregion in subregions]

@app.callback(
    Output('source-port-dropdown', 'options'),
    [Input('source-subregion-dropdown', 'value')]
)
def update_port_options(selected_subregions):
    filtered_ship_data = ship_data[ship_data['source_subregion'].isin(selected_subregions)]
    ports = filtered_ship_data['source_port'].unique()
    return [{'label': port, 'value': port} for port in ports]



@app.callback(
    Output('dest-subregion-dropdown', 'options'),
    [Input('dest-region-dropdown', 'value')]
)
def update_dest_subregion_options(selected_dest_regions):
    if 'selectall' in selected_dest_regions:
        subregions = combined_data['subregion'].dropna().unique()
        return [{'label': subregion, 'value': subregion} for subregion in subregions]

    elif 'deselectall' in selected_dest_regions:
        return []

    else:
        filtered_combined_data = combined_data[combined_data['region'].isin(selected_dest_regions)]
        subregions = filtered_combined_data['subregion'].dropna().unique()
        return [{'label': subregion, 'value': subregion} for subregion in subregions]


@app.callback(
    Output('dest-port-dropdown', 'options'),
    [Input('dest-subregion-dropdown', 'value')]
)
def update_dest_port_options(selected_dest_subregions):
    if 'selectall' in selected_dest_subregions:
        filtered_combined_data = combined_data
        selected_dest_subregions.remove('selectall')
    elif 'deselectall' in selected_dest_subregions:
        filtered_combined_data = pd.DataFrame()  # Empty DataFrame when 'deselectall' is selected
        selected_dest_subregions.remove('deselectall')
    else:
        filtered_combined_data = combined_data[combined_data['subregion'].isin(selected_dest_subregions)]

    ports = filtered_combined_data['port_name'].dropna().unique()
    return [{'label': port, 'value': port} for port in ports]





@app.callback(
    Output('map', 'figure'),
    [Input('imo-search', 'value'),
     Input('source-region-dropdown', 'value'),
     Input('source-subregion-dropdown', 'value'),
     Input('source-port-dropdown', 'value'),
     Input('dest-region-dropdown', 'value'),
     Input('dest-subregion-dropdown', 'value'),
     Input('dest-port-dropdown', 'value'),
     Input('checklist-idle-input', 'value'),
     Input('checklist-emptyfull-input', 'value'),
     Input('fulldraft-slider','value'),
     ]
)
def update_map(imo_number, selected_regions,selected_subregions,selected_ports,dest_regions,dest_subregions,dest_ports,
               selected_idle_status,selected_emptyfull_status,fulldraft):
    filtered_ship_data = combined_data  # Initialize with the combined data

    #print(combined_data.columns.tolist())
    #print(filtered_ship_data['idle_y'].head())

     # Filter based on selected idle status
    #if selected_idle_status:
    #    filtered_ship_data = combined_data[combined_data['idle'].isin(selected_idle_status)]
    
    if fulldraft:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['max_draft'] <= fulldraft]


    if selected_emptyfull_status:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['empty_full'].isin(selected_emptyfull_status)]

    if selected_idle_status:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['idle_y'].isin(selected_idle_status)]


    if dest_ports and 'selectall' not in dest_ports:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['port_name'].isin(dest_ports)]


    if dest_regions and 'selectall' not in dest_regions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['region'].isin(dest_regions)]

    if dest_subregions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['subregion'].isin(dest_subregions)]

    # Filter data based on selected regions
    if selected_regions and 'selectall' not in selected_regions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_region'].isin(selected_regions)]

    # Filter data based on sub regions
    if selected_subregions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_subregion'].isin(selected_subregions)]

    # Filter data based on IMO number if provided
    if imo_number and imo_number.isdigit():
        imo_number = int(imo_number)
        filtered_ship_data = filtered_ship_data[filtered_ship_data['imo'] == imo_number]

    if selected_ports:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_port'].isin(selected_ports)]
    
    


    # Convert 'seen_date' column to datetime
    filtered_ship_data['seen_date'] = pd.to_datetime(filtered_ship_data['seen_date'])

    # Group by 'imo' and get the latest 'seen_date' for each IMO
    latest_dates = filtered_ship_data.groupby('imo')['seen_date'].max().reset_index()

    # Merge to get the lat/lon corresponding to the latest 'seen_date'
    latest_locations = pd.merge(latest_dates, filtered_ship_data, on=['imo', 'seen_date'], how='left')

    # Create a column 'hours_since_latest' representing the difference in hours from the latest 'seen_date'
    latest_locations['hours_since_latest'] = (latest_locations['seen_date'].max() - latest_locations['seen_date']).dt.total_seconds() / 3600

    # Create a new column 'size' to differentiate between latest and previous locations
    latest_locations['size'] = 10  # Default size for previous locations
    #latest_locations.loc[latest_locations['hours_since_latest'] == 0, 'size'] = 20  # Larger size for the latest location
 
    # Plot the map
    imo_map = px.scatter_mapbox(
        latest_locations,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        
        title=f'IMO and Ports Locations for {selected_regions if selected_regions else "All"}',
        color='region'
    )

    

    # Update marker sizes for differentiating latest and previous locations
    imo_map.update_traces(marker=dict(size=latest_locations['size']))

    imo_map.update_layout(
        mapbox_style="open-street-map",
        margin={"r": 0, "t": 0, "l": 0, "b": 0}
    )

    # Add ports data to the map
    ports_map = px.scatter_mapbox(
        ports_data,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        text='name',
        title='IMO and Ports Locations'
    )

    ports_map.update_traces(marker=dict(size=10, color='grey',opacity=0.2))

    for data in ports_map.data:
        imo_map.add_trace(data)

    imo_map.update_layout(
        mapbox_style="open-street-map",
        margin={"r": 0, "t": 0, "l": 0, "b": 0}
    )

    return imo_map

#fig.show()
if __name__ == '__main__':
    app.run_server(debug=True)


'''
#after completing the lines
8

"""import pandas as pd
import plotly.express as px
import dash
from dash import html, dcc
from dash.dependencies import Input, Output
import dash_bootstrap_components as dbc
import plotly.graph_objects as go



# Read the CSV files for IMO and ports data
ship_data = pd.read_csv("imo_tracking.csv")
ports_data = pd.read_csv("ports.csv")
regions = pd.read_csv("regions.csv")
yy_ship_count = pd.read_csv("yy_ship_count.csv")

combined_data = pd.merge(ship_data, yy_ship_count, on='imo', how='left')
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Get unique values for the source region dropdown
source_regions = ship_data['source_region'].unique()

app.layout = dbc.Container([
    html.H1("IMO and Ports Location Data", style={'text-align': 'center'}),
    dbc.Row([
        dbc.Col(
            html.Div([
                dcc.Input(
                    id='imo-search',
                    type='text',
                    placeholder='Enter IMO number...',
                    value='',  # Initial value of the search box
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Regions"),
                dcc.Dropdown(
                    id='source-region-dropdown',
                    options=[{'label': 'Select All', 'value': 'selectall'},
                             {'label': 'Deselect All', 'value': 'deselectall'}] + [{'label': region, 'value': region} for region in source_regions],
                    value=['selectall'],  # Set default value as 'selectall'
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Select Sub-regions"),
                dcc.Dropdown(
                    id='source-subregion-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': subregion, 'value': subregion} for subregion in ship_data['source_subregion'].unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Select Ports"),
                dcc.Dropdown(
                    id='source-port-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': port, 'value': port} for port in ship_data['source_port'].unique()],
                    value=[],  # Initial value for port dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Dest Region"),
                dcc.Dropdown(
                    id='dest-region-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] +[{'label': region, 'value': region} for region in regions['region'].unique()],
                    value=[],  # Initial value for region dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),

                html.Label("Dest Sub-region"),
                dcc.Dropdown(
                    id='dest-subregion-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': subregion, 'value': subregion} for subregion in combined_data['subregion'].dropna().unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),

                html.Label("Dest port"),
                dcc.Dropdown(
                    id='dest-port-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': port_name, 'value': port_name} for port_name in combined_data['port_name'].dropna().unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                dbc.Label("Idle Ships"),
                dbc.Checklist(
                    options=[
                        {"label": "idle", "value": 1},
                        {"label": "active", "value": 0},
                    ],
                    
                    value=[],
                    id="checklist-idle-input",
                    inline=True,
                ),
                dbc.Label("empty full"),
                dbc.Checklist(
                    options=[
                        {"label": "empty", "value": 1},
                        {"label": "full", "value": 0},
                    ],
                    
                    value=[],
                    id="checklist-emptyfull-input",
                    inline=True,
                ),
                dbc.Label("Max Full Draft (meter)"),
                dcc.Slider(
                    id='fulldraft-slider',
                    min=11,
                    max=14,
                    step=0.2,
                    marks={value: str(value) for value in range(11, 15) if value % 1 == 0},

                    value=11,  # Initial value
                ),                

                          
   
                
                # Output for displaying the filtered data
           
            ]),
            width=3  # Left side column width
        ),
        dbc.Col(
            html.Div([
                dcc.Graph(
                    id='map'
                )
            ]),
            width=8  # Right side column width
        )
    ], justify="left")  # Center-aligns the row
])    
@app.callback(
    Output('source-subregion-dropdown', 'options'),
    [Input('source-region-dropdown', 'value')]
)
def update_subregion_options(selected_regions):
    if 'selectall' in selected_regions:
        filtered_ship_data = ship_data
        selected_regions.remove('selectall')
    elif 'deselectall' in selected_regions:
        filtered_ship_data = pd.DataFrame()  # Empty DataFrame when 'deselectall' is selected
        selected_regions.remove('deselectall')
    else:
        filtered_ship_data = ship_data[ship_data['source_region'].isin(selected_regions)]

    subregions = filtered_ship_data['source_subregion'].unique()
    return [{'label': subregion, 'value': subregion} for subregion in subregions]

@app.callback(
    Output('source-port-dropdown', 'options'),
    [Input('source-subregion-dropdown', 'value')]
)
def update_port_options(selected_subregions):
    filtered_ship_data = ship_data[ship_data['source_subregion'].isin(selected_subregions)]
    ports = filtered_ship_data['source_port'].unique()
    return [{'label': port, 'value': port} for port in ports]



@app.callback(
    Output('dest-subregion-dropdown', 'options'),
    [Input('dest-region-dropdown', 'value')]
)
def update_dest_subregion_options(selected_dest_regions):
    if 'selectall' in selected_dest_regions:
        subregions = combined_data['subregion'].dropna().unique()
        return [{'label': subregion, 'value': subregion} for subregion in subregions]

    elif 'deselectall' in selected_dest_regions:
        return []

    else:
        filtered_combined_data = combined_data[combined_data['region'].isin(selected_dest_regions)]
        subregions = filtered_combined_data['subregion'].dropna().unique()
        return [{'label': subregion, 'value': subregion} for subregion in subregions]


@app.callback(
    Output('dest-port-dropdown', 'options'),
    [Input('dest-subregion-dropdown', 'value')]
)
def update_dest_port_options(selected_dest_subregions):
    if 'selectall' in selected_dest_subregions:
        filtered_combined_data = combined_data
        selected_dest_subregions.remove('selectall')
    elif 'deselectall' in selected_dest_subregions:
        filtered_combined_data = pd.DataFrame()  # Empty DataFrame when 'deselectall' is selected
        selected_dest_subregions.remove('deselectall')
    else:
        filtered_combined_data = combined_data[combined_data['subregion'].isin(selected_dest_subregions)]

    ports = filtered_combined_data['port_name'].dropna().unique()
    return [{'label': port, 'value': port} for port in ports]





@app.callback(
    Output('map', 'figure'),
    [Input('imo-search', 'value'),
     Input('source-region-dropdown', 'value'),
     Input('source-subregion-dropdown', 'value'),
     Input('source-port-dropdown', 'value'),
     Input('dest-region-dropdown', 'value'),
     Input('dest-subregion-dropdown', 'value'),
     Input('dest-port-dropdown', 'value'),
     Input('checklist-idle-input', 'value'),
     Input('checklist-emptyfull-input', 'value'),
     Input('fulldraft-slider','value'),
     ]
)
def update_map(imo_number, selected_regions,selected_subregions,selected_ports,dest_regions,dest_subregions,dest_ports,
               selected_idle_status,selected_emptyfull_status,fulldraft):
    filtered_ship_data = combined_data  # Initialize with the combined data

    #print(combined_data.columns.tolist())
    #print(filtered_ship_data['idle_y'].head())

     # Filter based on selected idle status
    #if selected_idle_status:
    #    filtered_ship_data = combined_data[combined_data['idle'].isin(selected_idle_status)]
    '''if fulldraft:
        fulldraft_list = [fulldraft]
        filtered_ship_data = filtered_ship_data[filtered_ship_data['max_draft'].isin(fulldraft_list)]'''
    if fulldraft:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['max_draft'] <= fulldraft]


    if selected_emptyfull_status:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['empty_full'].isin(selected_emptyfull_status)]

    if selected_idle_status:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['idle_y'].isin(selected_idle_status)]


    if dest_ports and 'selectall' not in dest_ports:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['port_name'].isin(dest_ports)]


    if dest_regions and 'selectall' not in dest_regions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['region'].isin(dest_regions)]

    if dest_subregions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['subregion'].isin(dest_subregions)]

    # Filter data based on selected regions
    if selected_regions and 'selectall' not in selected_regions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_region'].isin(selected_regions)]

    # Filter data based on sub regions
    if selected_subregions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_subregion'].isin(selected_subregions)]

    # Filter data based on IMO number if provided
    if imo_number and imo_number.isdigit():
        imo_number = int(imo_number)
        filtered_ship_data = filtered_ship_data[filtered_ship_data['imo'] == imo_number]

    if selected_ports:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_port'].isin(selected_ports)]
    
    


    # Convert 'seen_date' column to datetime
    filtered_ship_data['seen_date'] = pd.to_datetime(filtered_ship_data['seen_date'])

    # Group by 'imo' and get the latest 'seen_date' for each IMO
    latest_dates = filtered_ship_data.groupby('imo')['seen_date'].max().reset_index()

    # Merge to get the lat/lon corresponding to the latest 'seen_date'
    latest_locations = pd.merge(latest_dates, filtered_ship_data, on=['imo', 'seen_date'], how='left')

    # Create a column 'hours_since_latest' representing the difference in hours from the latest 'seen_date'
    latest_locations['hours_since_latest'] = (latest_locations['seen_date'].max() - latest_locations['seen_date']).dt.total_seconds() / 3600

    # Create a new column 'size' to differentiate between latest and previous locations
    latest_locations['size'] = 10  # Default size for previous locations
    #latest_locations.loc[latest_locations['hours_since_latest'] == 0, 'size'] = 20  # Larger size for the latest location
 

    '''imo_map_trace = go.Scattermapbox(
        mode="markers+lines",
        lon=[10, 20, 30],
        lat=[10, 20, 30],
        marker={'size': 10}
    )

    # Define the second trace for your Scattermapbox (imo_map)
    fig_trace = go.Scattermapbox(
        mode="markers+lines",
        lon=[-50, -60, 40],
        lat=[30, 10, -20],
        marker={'size': 10}
    )'''
    traces = []
    for imo in ship_data['imo'].unique():

        imo_df = ship_data[ship_data['imo'] == imo]
        imo_map_trace = go.Scattermapbox(
            mode="lines",
            lon=imo_df['lon'],
            lat=imo_df['lat'],
            marker={'size': 10},
            #name=f'imo={imo}'
        )
        traces.append(imo_map_trace)


    # Plot the map
    imo_map = px.scatter_mapbox(
        latest_locations,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        
        title=f'IMO and Ports Locations for {selected_regions if selected_regions else "All"}',
        color='region'
    )

    

    # Update marker sizes for differentiating latest and previous locations
    imo_map.update_traces(marker=dict(size=latest_locations['size']))
    imo_map.update_layout(mapbox_style="open-street-map", margin={"r": 0, "t": 0, "l": 0, "b": 0})

    # Add the traces to the `imo_map` object
    for trace in traces:
        imo_map.add_trace(trace)
    #imo_map.add_trace(fig_trace)

    # Add ports data to the map
    ports_map = px.scatter_mapbox(
        ports_data,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        text='name',
        title='IMO and Ports Locations'
    )

    ports_map.update_traces(marker=dict(size=10, color='grey',opacity=0.4))

    for data in ports_map.data:
        imo_map.add_trace(data)

    imo_map.update_layout(
        mapbox_style="open-street-map",
        margin={"r": 0, "t": 0, "l": 0, "b": 0}
    )

    '''fig = go.Figure(go.Scattermapbox(
        mode = "markers+lines",
        lon = [10, 20, 30],
        lat = [10, 20,30],
        marker = {'size': 10}))

    fig.add_trace(go.Scattermapbox(
        mode = "markers+lines",
        lon = [-50, -60,40],
        lat = [30, 10, -20],
        marker = {'size': 10}))

    fig.update_layout(

        margin={'l': 0, 't': 0, 'b': 0, 'r': 0},
        mapbox={
            'center': {'lon': -20, 'lat': -20},  # Define the center once
            'style': "open-street-map",
            'zoom': 1
        }
    )'''
    return imo_map

#fig.show()
if __name__ == '__main__':
    app.run_server(debug=True)


"""

9

#after adding the labels with the lines

"""
import pandas as pd
import plotly.express as px
import dash
from dash import html, dcc
from dash.dependencies import Input, Output
import dash_bootstrap_components as dbc
import plotly.graph_objects as go



# Read the CSV files for IMO and ports data
ship_data = pd.read_csv("imo_tracking.csv")
ports_data = pd.read_csv("ports.csv")
regions = pd.read_csv("regions.csv")
yy_ship_count = pd.read_csv("yy_ship_count.csv")

combined_data = pd.merge(ship_data, yy_ship_count, on='imo', how='left')
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Get unique values for the source region dropdown
source_regions = ship_data['source_region'].unique()

app.layout = dbc.Container([
    html.H1("IMO and Ports Location Data", style={'text-align': 'center'}),
    dbc.Row([
        dbc.Col(
            html.Div([
                dcc.Input(
                    id='imo-search',
                    type='text',
                    placeholder='Enter IMO number...',
                    value='',  # Initial value of the search box
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Regions"),
                dcc.Dropdown(
                    id='source-region-dropdown',
                    options=[{'label': 'Select All', 'value': 'selectall'},
                             {'label': 'Deselect All', 'value': 'deselectall'}] + [{'label': region, 'value': region} for region in source_regions],
                    value=['selectall'],  # Set default value as 'selectall'
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Select Sub-regions"),
                dcc.Dropdown(
                    id='source-subregion-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': subregion, 'value': subregion} for subregion in ship_data['source_subregion'].unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Select Ports"),
                dcc.Dropdown(
                    id='source-port-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': port, 'value': port} for port in ship_data['source_port'].unique()],
                    value=[],  # Initial value for port dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Dest Region"),
                dcc.Dropdown(
                    id='dest-region-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] +[{'label': region, 'value': region} for region in regions['region'].unique()],
                    value=[],  # Initial value for region dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),

                html.Label("Dest Sub-region"),
                dcc.Dropdown(
                    id='dest-subregion-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': subregion, 'value': subregion} for subregion in combined_data['subregion'].dropna().unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),

                html.Label("Dest port"),
                dcc.Dropdown(
                    id='dest-port-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': port_name, 'value': port_name} for port_name in combined_data['port_name'].dropna().unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                dbc.Label("Idle Ships"),
                dbc.Checklist(
                    options=[
                        {"label": "idle", "value": 1},
                        {"label": "active", "value": 0},
                    ],
                    
                    value=[],
                    id="checklist-idle-input",
                    inline=True,
                ),
                dbc.Label("empty full"),
                dbc.Checklist(
                    options=[
                        {"label": "empty", "value": 1},
                        {"label": "full", "value": 0},
                    ],
                    
                    value=[],
                    id="checklist-emptyfull-input",
                    inline=True,
                ),
                dbc.Label("Max Full Draft (meter)"),
                dcc.Slider(
                    id='fulldraft-slider',
                    min=11,
                    max=14,
                    step=0.2,
                    marks={value: str(value) for value in range(11, 15) if value % 1 == 0},

                    value=11,  # Initial value
                ),                

                          
   
                
                # Output for displaying the filtered data
           
            ]),
            width=3  # Left side column width
        ),
        dbc.Col(
            html.Div([
                dcc.Graph(
                    id='map'
                )
            ]),
            width=8  # Right side column width
        )
    ], justify="left")  # Center-aligns the row
])    
@app.callback(
    Output('source-subregion-dropdown', 'options'),
    [Input('source-region-dropdown', 'value')]
)
def update_subregion_options(selected_regions):
    if 'selectall' in selected_regions:
        filtered_ship_data = ship_data
        selected_regions.remove('selectall')
    elif 'deselectall' in selected_regions:
        filtered_ship_data = pd.DataFrame()  # Empty DataFrame when 'deselectall' is selected
        selected_regions.remove('deselectall')
    else:
        filtered_ship_data = ship_data[ship_data['source_region'].isin(selected_regions)]

    subregions = filtered_ship_data['source_subregion'].unique()
    return [{'label': subregion, 'value': subregion} for subregion in subregions]

@app.callback(
    Output('source-port-dropdown', 'options'),
    [Input('source-subregion-dropdown', 'value')]
)
def update_port_options(selected_subregions):
    filtered_ship_data = ship_data[ship_data['source_subregion'].isin(selected_subregions)]
    ports = filtered_ship_data['source_port'].unique()
    return [{'label': port, 'value': port} for port in ports]



@app.callback(
    Output('dest-subregion-dropdown', 'options'),
    [Input('dest-region-dropdown', 'value')]
)
def update_dest_subregion_options(selected_dest_regions):
    if 'selectall' in selected_dest_regions:
        subregions = combined_data['subregion'].dropna().unique()
        return [{'label': subregion, 'value': subregion} for subregion in subregions]

    elif 'deselectall' in selected_dest_regions:
        return []

    else:
        filtered_combined_data = combined_data[combined_data['region'].isin(selected_dest_regions)]
        subregions = filtered_combined_data['subregion'].dropna().unique()
        return [{'label': subregion, 'value': subregion} for subregion in subregions]


@app.callback(
    Output('dest-port-dropdown', 'options'),
    [Input('dest-subregion-dropdown', 'value')]
)
def update_dest_port_options(selected_dest_subregions):
    if 'selectall' in selected_dest_subregions:
        filtered_combined_data = combined_data
        selected_dest_subregions.remove('selectall')
    elif 'deselectall' in selected_dest_subregions:
        filtered_combined_data = pd.DataFrame()  # Empty DataFrame when 'deselectall' is selected
        selected_dest_subregions.remove('deselectall')
    else:
        filtered_combined_data = combined_data[combined_data['subregion'].isin(selected_dest_subregions)]

    ports = filtered_combined_data['port_name'].dropna().unique()
    return [{'label': port, 'value': port} for port in ports]





@app.callback(
    Output('map', 'figure'),
    [Input('imo-search', 'value'),
     Input('source-region-dropdown', 'value'),
     Input('source-subregion-dropdown', 'value'),
     Input('source-port-dropdown', 'value'),
     Input('dest-region-dropdown', 'value'),
     Input('dest-subregion-dropdown', 'value'),
     Input('dest-port-dropdown', 'value'),
     Input('checklist-idle-input', 'value'),
     Input('checklist-emptyfull-input', 'value'),
     Input('fulldraft-slider','value'),
     ]
)
def update_map(imo_number, selected_regions,selected_subregions,selected_ports,dest_regions,dest_subregions,dest_ports,
               selected_idle_status,selected_emptyfull_status,fulldraft):
    filtered_ship_data = combined_data  # Initialize with the combined data

    #print(combined_data.columns.tolist())
    #print(filtered_ship_data['idle_y'].head())

     # Filter based on selected idle status
    #if selected_idle_status:
    #    filtered_ship_data = combined_data[combined_data['idle'].isin(selected_idle_status)]
    '''if fulldraft:
        fulldraft_list = [fulldraft]
        filtered_ship_data = filtered_ship_data[filtered_ship_data['max_draft'].isin(fulldraft_list)]'''
    if fulldraft:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['max_draft'] <= fulldraft]


    if selected_emptyfull_status:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['empty_full'].isin(selected_emptyfull_status)]

    if selected_idle_status:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['idle_y'].isin(selected_idle_status)]


    if dest_ports and 'selectall' not in dest_ports:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['port_name'].isin(dest_ports)]


    if dest_regions and 'selectall' not in dest_regions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['region'].isin(dest_regions)]

    if dest_subregions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['subregion'].isin(dest_subregions)]

    # Filter data based on selected regions
    if selected_regions and 'selectall' not in selected_regions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_region'].isin(selected_regions)]

    # Filter data based on sub regions
    if selected_subregions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_subregion'].isin(selected_subregions)]

    # Filter data based on IMO number if provided
    if imo_number and imo_number.isdigit():
        imo_number = int(imo_number)
        filtered_ship_data = filtered_ship_data[filtered_ship_data['imo'] == imo_number]

    if selected_ports:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_port'].isin(selected_ports)]
    
    


    # Convert 'seen_date' column to datetime
    filtered_ship_data['seen_date'] = pd.to_datetime(filtered_ship_data['seen_date'])

    # Group by 'imo' and get the latest 'seen_date' for each IMO
    latest_dates = filtered_ship_data.groupby('imo')['seen_date'].max().reset_index()

    # Merge to get the lat/lon corresponding to the latest 'seen_date'
    latest_locations = pd.merge(latest_dates, filtered_ship_data, on=['imo', 'seen_date'], how='left')

    # Create a column 'hours_since_latest' representing the difference in hours from the latest 'seen_date'
    latest_locations['hours_since_latest'] = (latest_locations['seen_date'].max() - latest_locations['seen_date']).dt.total_seconds() / 3600

    # Create a new column 'size' to differentiate between latest and previous locations
    latest_locations['size'] = 10  # Default size for previous locations
    #latest_locations.loc[latest_locations['hours_since_latest'] == 0, 'size'] = 20  # Larger size for the latest location
 

    '''imo_map_trace = go.Scattermapbox(
        mode="markers+lines",
        lon=[10, 20, 30],
        lat=[10, 20, 30],
        marker={'size': 10}
    )

    # Define the second trace for your Scattermapbox (imo_map)
    fig_trace = go.Scattermapbox(
        mode="markers+lines",
        lon=[-50, -60, 40],
        lat=[30, 10, -20],
        marker={'size': 10}
    )'''

    
    
    # Get unique regions and assign a unique color to each region
    unique_regions = filtered_ship_data['region'].unique()
    color_map = {
        region: px.colors.qualitative.Set1[i % len(px.colors.qualitative.Set1)]
        for i, region in enumerate(unique_regions)
    }

    traces = []
    #color = 'Same Color'  # Set a common color for all traces

    for imo in filtered_ship_data['imo'].unique():
        imo_df = filtered_ship_data[filtered_ship_data['imo'] == imo]


        customdata_columns = ['imo','region', 'subregion', 'port_name','model_eta', 'name', 'size','draft','max_draft','ef','stated_destination','stated_eta','begin_port_name','begin_region','origin_type','idle_y']  # Columns to include in customdata
    
            # Create hovertemplate dynamically based on columns
        hovertemplate = "<br>".join([f"<b>{col}</b>: %{{customdata[{i}]}}" for i, col in enumerate(customdata_columns)]) + "<extra></extra>"
    
            # Create customdata DataFrame dynamically based on columns
        customdata = pd.DataFrame({col: imo_df[col] for col in customdata_columns})
        
        imo_map_trace = go.Scattermapbox(
            mode="lines",
            lon=imo_df['lon'],
            lat=imo_df['lat'],
            marker={'size': 5},
            line=dict(color=color_map.get(imo_df['region'].iloc[0], 'white')),  # Assign color based on 'region'
            name=f'imo={imo}',
            hovertemplate=hovertemplate,
            customdata=customdata
            #hovertemplate='<b>Region</b>: %{customdata}<extra></extra>',  # Customize the hover tooltip
            #customdata=imo_df['region']
            showlegend=False



            #hovertemplate='<b>Region</b>: %{customdata[0]}<br><b>Size</b>: %{customdata[1]}<extra></extra><br><b>imo</b>: %{customdata[2]}<extra></extra>',  # Customize the hover tooltip
            #customdata=pd.DataFrame({'Region': imo_df['region'], 'Size': imo_df['size'],'imo': imo_df['imo']})  # Assign 'region' and 'size' data for the current 'imo' as customdata

            #hovertemplate='<b>Region</b>: %{customdata[0]}<br><b>Size</b>: %{customdata[1]}<extra></extra>',  # Customize the hover tooltip
            #customdata=[imo_df['region'], imo_df['size']]
        )
        # Append each Scattermapbox trace to the 'traces' list
        traces.append(imo_map_trace)

    # Create a base map using plotly express scatter_mapbox
    imo_map = px.scatter_mapbox(
        latest_locations,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        title=f'IMO and Ports Locations for {selected_regions if selected_regions else "All"}',
        color='region' , # Assuming 'region' column determines color in latest_locations
        color_discrete_map=color_map  # Apply the same color map to ensure consistency
    )

    
    imo_map.update_traces(marker=dict(size=15))
    
    # Update marker sizes for differentiating latest and previous locations
    #imo_map.update_traces(marker=dict(size=latest_locations['size']))
    imo_map.update_layout(mapbox_style="open-street-map", margin={"r": 0, "t": 0, "l": 0, "b": 0})

    # Add the traces to the `imo_map` object
    for trace in traces:
        imo_map.add_trace(trace)
    #imo_map.add_trace(fig_trace)

    # Add ports data to the map
    ports_map = px.scatter_mapbox(
        ports_data,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        text='name',
        title='IMO and Ports Locations'
    )

    ports_map.update_traces(marker=dict(size=10, color='grey',opacity=0.8))

    for data in ports_map.data:
        imo_map.add_trace(data)

    imo_map.update_layout(
        mapbox_style="open-street-map",
        margin={"r": 0, "t": 0, "l": 0, "b": 0}
    )

    '''fig = go.Figure(go.Scattermapbox(
        mode = "markers+lines",
        lon = [10, 20, 30],
        lat = [10, 20,30],
        marker = {'size': 10}))

    fig.add_trace(go.Scattermapbox(
        mode = "markers+lines",
        lon = [-50, -60,40],
        lat = [30, 10, -20],
        marker = {'size': 10}))

    fig.update_layout(

        margin={'l': 0, 't': 0, 'b': 0, 'r': 0},
        mapbox={
            'center': {'lon': -20, 'lat': -20},  # Define the center once
            'style': "open-street-map",
            'zoom': 1
        }
    )'''
    return imo_map

#fig.show()
if __name__ == '__main__':
    app.run_server(debug=True)


"""
10

'''
import pandas as pd
import plotly.express as px
import dash
from dash import html, dcc
from dash.dependencies import Input, Output
import dash_bootstrap_components as dbc
import plotly.graph_objects as go



# Read the CSV files for IMO and ports data
ship_data = pd.read_csv("https://dl.dropboxusercontent.com/scl/fi/4bz3qrjqhbevtlqn4w131/imo_tracking.csv?rlkey=w9evtnyx2oo1wwx2sdaw0190r&dl=0")
ports_data = pd.read_csv("https://dl.dropboxusercontent.com/scl/fi/4h83p47fpaz5v1tnhaw69/ports.csv?rlkey=1erpymfq8eq6fzst5dcxi0wt3&dl=0")
regions = pd.read_csv("https://dl.dropboxusercontent.com/scl/fi/dhow2fvxtibo46gjget76/regions.csv?rlkey=xsoa08k36f2z8q4rqpy4p29y8&dl=0")
yy_ship_count = pd.read_csv("https://dl.dropboxusercontent.com/scl/fi/gzu9k87fxiutcf0q6uqo3/yy_ship_count.csv?rlkey=04hv0trgaoe0myk3pjcsmnu7e&dl=0")

combined_data = pd.merge(ship_data, yy_ship_count, on='imo', how='left')
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Get unique values for the source region dropdown
source_regions = ship_data['source_region'].unique()

app.layout = dbc.Container([
    
    dbc.Row([
        dbc.Col(
            html.Div([
                dcc.Input(
                    id='imo-search',
                    type='text',
                    placeholder='Enter IMO number...',
                    value='',  # Initial value of the search box
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Regions"),
                dcc.Dropdown(
                    id='source-region-dropdown',
                    options=[{'label': 'Select All', 'value': 'selectall'},
                             {'label': 'Deselect All', 'value': 'deselectall'}] + [{'label': region, 'value': region} for region in source_regions],
                    value=['selectall'],  # Set default value as 'selectall'
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Select Sub-regions"),
                dcc.Dropdown(
                    id='source-subregion-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': subregion, 'value': subregion} for subregion in ship_data['source_subregion'].unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Select Ports"),
                dcc.Dropdown(
                    id='source-port-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': port, 'value': port} for port in ship_data['source_port'].unique()],
                    value=[],  # Initial value for port dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Dest Region"),
                dcc.Dropdown(
                    id='dest-region-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] +[{'label': region, 'value': region} for region in regions['region'].unique()],
                    value=[],  # Initial value for region dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),

                html.Label("Dest Sub-region"),
                dcc.Dropdown(
                    id='dest-subregion-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': subregion, 'value': subregion} for subregion in combined_data['subregion'].dropna().unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),

                html.Label("Dest port"),
                dcc.Dropdown(
                    id='dest-port-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': port_name, 'value': port_name} for port_name in combined_data['port_name'].dropna().unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                dbc.Label("Idle Ships"),
                dbc.Checklist(
                    options=[
                        {"label": "idle", "value": 1},
                        {"label": "active", "value": 0},
                    ],
                    
                    value=[],
                    id="checklist-idle-input",
                    inline=True,
                ),
                dbc.Label("empty full"),
                dbc.Checklist(
                    options=[
                        {"label": "empty", "value": 1},
                        {"label": "full", "value": 0},
                    ],
                    
                    value=[],
                    id="checklist-emptyfull-input",
                    inline=True,
                ),
                dbc.Label("Max Full Draft (meter)"),
                dcc.Slider(
                    id='fulldraft-slider',
                    min=11,
                    max=14,
                    step=0.2,
                    marks={value: str(value) for value in range(11, 15) if value % 1 == 0},

                    value=11,  # Initial value
                ),  
                
                
                html.Label('Select a Time Range (in hours):'),
                dcc.Slider(
                    id='time-range-slider',
                    min=5,
                    max=75,
                    step=1,
                    marks={i: str(i) for i in range(5, 76, 5)},
                    value=30  # Initial time range value
                )
                          
   
                
                # Output for displaying the filtered data
           
            ]),
            width=3  # Left side column width
        ),
        dbc.Col(
            html.Div([
                dcc.Graph(
                    id='map'
                )
            ]),
            width=8  # Right side column width
        )
    ], justify="left")  # Center-aligns the row
])    
@app.callback(
    Output('source-subregion-dropdown', 'options'),
    [Input('source-region-dropdown', 'value')]
)
def update_subregion_options(selected_regions):
    if 'selectall' in selected_regions:
        filtered_ship_data = ship_data
        selected_regions.remove('selectall')
    elif 'deselectall' in selected_regions:
        filtered_ship_data = pd.DataFrame()  # Empty DataFrame when 'deselectall' is selected
        selected_regions.remove('deselectall')
    else:
        filtered_ship_data = ship_data[ship_data['source_region'].isin(selected_regions)]

    subregions = filtered_ship_data['source_subregion'].unique()
    return [{'label': subregion, 'value': subregion} for subregion in subregions]

@app.callback(
    Output('source-port-dropdown', 'options'),
    [Input('source-subregion-dropdown', 'value')]
)
def update_port_options(selected_subregions):
    filtered_ship_data = ship_data[ship_data['source_subregion'].isin(selected_subregions)]
    ports = filtered_ship_data['source_port'].unique()
    return [{'label': port, 'value': port} for port in ports]



@app.callback(
    Output('dest-subregion-dropdown', 'options'),
    [Input('dest-region-dropdown', 'value')]
)
def update_dest_subregion_options(selected_dest_regions):
    if 'selectall' in selected_dest_regions:
        subregions = combined_data['subregion'].dropna().unique()
        return [{'label': subregion, 'value': subregion} for subregion in subregions]

    elif 'deselectall' in selected_dest_regions:
        return []

    else:
        filtered_combined_data = combined_data[combined_data['region'].isin(selected_dest_regions)]
        subregions = filtered_combined_data['subregion'].dropna().unique()
        return [{'label': subregion, 'value': subregion} for subregion in subregions]


@app.callback(
    Output('dest-port-dropdown', 'options'),
    [Input('dest-subregion-dropdown', 'value')]
)
def update_dest_port_options(selected_dest_subregions):
    if 'selectall' in selected_dest_subregions:
        filtered_combined_data = combined_data
        selected_dest_subregions.remove('selectall')
    elif 'deselectall' in selected_dest_subregions:
        filtered_combined_data = pd.DataFrame()  # Empty DataFrame when 'deselectall' is selected
        selected_dest_subregions.remove('deselectall')
    else:
        filtered_combined_data = combined_data[combined_data['subregion'].isin(selected_dest_subregions)]

    ports = filtered_combined_data['port_name'].dropna().unique()
    return [{'label': port, 'value': port} for port in ports]





@app.callback(
    Output('map', 'figure'),
    [Input('imo-search', 'value'),
     Input('source-region-dropdown', 'value'),
     Input('source-subregion-dropdown', 'value'),
     Input('source-port-dropdown', 'value'),
     Input('dest-region-dropdown', 'value'),
     Input('dest-subregion-dropdown', 'value'),
     Input('dest-port-dropdown', 'value'),
     Input('checklist-idle-input', 'value'),
     Input('checklist-emptyfull-input', 'value'),
     Input('fulldraft-slider','value'),
     Input('time-range-slider', 'value')
     ]
)
def update_map(imo_number, selected_regions,selected_subregions,selected_ports,dest_regions,dest_subregions,dest_ports,
               selected_idle_status,selected_emptyfull_status,fulldraft,selected_time_range):
    filtered_ship_data = combined_data  # Initialize with the combined data

    #print(combined_data.columns.tolist())
    #print(filtered_ship_data['idle_y'].head())

     # Filter based on selected idle status
    #if selected_idle_status:
    #    filtered_ship_data = combined_data[combined_data['idle'].isin(selected_idle_status)]

    if selected_time_range:
            # Convert 'seen_date' column to datetime format
            filtered_ship_data['seen_date'] = pd.to_datetime(filtered_ship_data['seen_date'], format='%Y-%m-%d %H:%M:%S')
            
            # Filter ship data based on the selected time range
            
            filtered_ship_data = filtered_ship_data[(filtered_ship_data['seen_date'] - filtered_ship_data['seen_date'].shift()).dt.total_seconds() / 3600 <= selected_time_range]
            
    


    if fulldraft:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['max_draft'] <= fulldraft]


    if selected_emptyfull_status:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['empty_full'].isin(selected_emptyfull_status)]

    if selected_idle_status:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['idle_y'].isin(selected_idle_status)]


    if dest_ports and 'selectall' not in dest_ports:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['port_name'].isin(dest_ports)]


    if dest_regions and 'selectall' not in dest_regions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['region'].isin(dest_regions)]

    if dest_subregions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['subregion'].isin(dest_subregions)]

    # Filter data based on selected regions
    if selected_regions and 'selectall' not in selected_regions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_region'].isin(selected_regions)]

    # Filter data based on sub regions
    if selected_subregions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_subregion'].isin(selected_subregions)]

    # Filter data based on IMO number if provided
    if imo_number and imo_number.isdigit():
        imo_number = int(imo_number)
        filtered_ship_data = filtered_ship_data[filtered_ship_data['imo'] == imo_number]

    if selected_ports:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_port'].isin(selected_ports)]
    
    


    # Convert 'seen_date' column to datetime
    filtered_ship_data['seen_date'] = pd.to_datetime(filtered_ship_data['seen_date'])

    # Group by 'imo' and get the latest 'seen_date' for each IMO
    latest_dates = filtered_ship_data.groupby('imo')['seen_date'].max().reset_index()

    # Merge to get the lat/lon corresponding to the latest 'seen_date'
    latest_locations = pd.merge(latest_dates, filtered_ship_data, on=['imo', 'seen_date'], how='left')

    # Create a column 'hours_since_latest' representing the difference in hours from the latest 'seen_date'
    latest_locations['hours_since_latest'] = (latest_locations['seen_date'].max() - latest_locations['seen_date']).dt.total_seconds() / 3600

    # Create a new column 'size' to differentiate between latest and previous locations
    latest_locations['size'] = 10  # Default size for previous locations
    #latest_locations.loc[latest_locations['hours_since_latest'] == 0, 'size'] = 20  # Larger size for the latest location

    
    
    # Get unique regions and assign a unique color to each region
    unique_regions = filtered_ship_data['region'].unique()
    color_map = {
        region: px.colors.qualitative.Set1[i % len(px.colors.qualitative.Set1)]
        for i, region in enumerate(unique_regions)
    }

    traces = []
    #color = 'Same Color'  # Set a common color for all traces

    for imo in filtered_ship_data['imo'].unique():
        imo_df = filtered_ship_data[filtered_ship_data['imo'] == imo]

        """if selected_time_range:
            # Convert 'seen_date' column to datetime format
            filtered_ship_data['seen_date'] = pd.to_datetime(filtered_ship_data['seen_date'], format='%Y-%m-%d %H:%M:%S')
            
            # Filter ship data based on the selected time range
            
            filtered_ship_data = filtered_ship_data[(filtered_ship_data['seen_date'] - filtered_ship_data['seen_date'].shift()).dt.total_seconds() / 3600 <= selected_time_range]
            """


        customdata_columns = ['imo','region', 'subregion', 'port_name','model_eta', 'name', 'size','draft','max_draft','ef','stated_destination','stated_eta','begin_port_name','begin_region','origin_type','idle_y']  # Columns to include in customdata
    
            # Create hovertemplate dynamically based on columns
        hovertemplate = "<br>".join([f"<b>{col}</b>: %{{customdata[{i}]}}" for i, col in enumerate(customdata_columns)]) + "<extra></extra>"
    
            # Create customdata DataFrame dynamically based on columns
        customdata = pd.DataFrame({col: imo_df[col] for col in customdata_columns})
        
        imo_map_trace = go.Scattermapbox(
            mode="lines",
            lon=imo_df['lon'],
            lat=imo_df['lat'],
            marker={'size': 5},
            line=dict(color=color_map.get(imo_df['region'].iloc[0], 'white')),  # Assign color based on 'region'
            name=f'imo={imo}',
            hovertemplate=hovertemplate,
            customdata=customdata,
            showlegend=False
        )
        # Append each Scattermapbox trace to the 'traces' list
        traces.append(imo_map_trace)

    # Create a base map using plotly express scatter_mapbox
    imo_map = px.scatter_mapbox(
        latest_locations,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        title=f'IMO and Ports Locations for {selected_regions if selected_regions else "All"}',
        color='region' , # Assuming 'region' column determines color in latest_locations
        color_discrete_map=color_map  # Apply the same color map to ensure consistency
    )

    
    imo_map.update_traces(marker=dict(size=15))
    
    # Update marker sizes for differentiating latest and previous locations
    #imo_map.update_traces(marker=dict(size=latest_locations['size']))
    imo_map.update_layout(mapbox_style="open-street-map", margin={"r": 0, "t": 0, "l": 0, "b": 0})

    # Add the traces to the `imo_map` object
    for trace in traces:
        imo_map.add_trace(trace)
    #imo_map.add_trace(fig_trace)

    # Add ports data to the map
    ports_map = px.scatter_mapbox(
        ports_data,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        text='name',
        title='IMO and Ports Locations'
    )

    ports_map.update_traces(marker=dict(size=10, color='grey',opacity=0.8))

    for data in ports_map.data:
        imo_map.add_trace(data)

    imo_map.update_layout(
        mapbox_style="open-street-map",
        margin={"r": 0, "t": 0, "l": 0, "b": 0}
    )


    return imo_map

#fig.show()
if __name__ == '__main__':
    app.run_server(debug=True)




'''

11
#after adding all filters
"""import pandas as pd
import plotly.express as px
import dash
from dash import html, dcc
from dash.dependencies import Input, Output
import dash_bootstrap_components as dbc
import plotly.graph_objects as go



# Read the CSV files for IMO and ports data
#ship_data = pd.read_csv("https://dl.dropboxusercontent.com/scl/fi/4bz3qrjqhbevtlqn4w131/imo_tracking.csv?rlkey=w9evtnyx2oo1wwx2sdaw0190r&dl=0")
ship_data = pd.read_csv("imo_tracking.csv")
#ports_data = pd.read_csv("https://dl.dropboxusercontent.com/scl/fi/4h83p47fpaz5v1tnhaw69/ports.csv?rlkey=1erpymfq8eq6fzst5dcxi0wt3&dl=0")
ports_data = pd.read_csv("ports.csv")
#regions = pd.read_csv("https://dl.dropboxusercontent.com/scl/fi/dhow2fvxtibo46gjget76/regions.csv?rlkey=xsoa08k36f2z8q4rqpy4p29y8&dl=0")
regions = pd.read_csv("regions.csv")
#yy_ship_count = pd.read_csv("https://dl.dropboxusercontent.com/scl/fi/gzu9k87fxiutcf0q6uqo3/yy_ship_count.csv?rlkey=04hv0trgaoe0myk3pjcsmnu7e&dl=0")
yy_ship_count = pd.read_csv("yy_ship_count.csv")
combined_data = pd.merge(ship_data, yy_ship_count, on='imo', how='left')

combined_data['seen_date'] = pd.to_datetime(combined_data['seen_date'], format='%Y-%m-%d %H:%M:%S')
combined_data['seen_date_hour'] = combined_data['seen_date'].dt.hour  # Extract hours from seen_date



app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Get unique values for the source region dropdown
source_regions = ship_data['source_region'].unique()

app.layout = dbc.Container([
    
    dbc.Row([
        dbc.Col(
            html.Div([
                dcc.Input(
                    id='imo-search',
                    type='text',
                    placeholder='Enter IMO number...',
                    value='',  # Initial value of the search box
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Regions"),
                dcc.Dropdown(
                    id='source-region-dropdown',
                    options=[{'label': 'Select All', 'value': 'selectall'},
                             {'label': 'Deselect All', 'value': 'deselectall'}] + [{'label': region, 'value': region} for region in source_regions],
                    value=['selectall'],  # Set default value as 'selectall'
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Select Sub-regions"),
                dcc.Dropdown(
                    id='source-subregion-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': subregion, 'value': subregion} for subregion in ship_data['source_subregion'].unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Select Ports"),
                dcc.Dropdown(
                    id='source-port-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': port, 'value': port} for port in ship_data['source_port'].unique()],
                    value=[],  # Initial value for port dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Dest Region"),
                dcc.Dropdown(
                    id='dest-region-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] +[{'label': region, 'value': region} for region in regions['region'].unique()],
                    value=[],  # Initial value for region dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),

                html.Label("Dest Sub-region"),
                dcc.Dropdown(
                    id='dest-subregion-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': subregion, 'value': subregion} for subregion in combined_data['subregion'].dropna().unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),

                html.Label("Dest port"),
                dcc.Dropdown(
                    id='dest-port-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': port_name, 'value': port_name} for port_name in combined_data['port_name'].dropna().unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                dbc.Label("Idle Ships"),
                dbc.Checklist(
                    options=[
                        {"label": "idle", "value": 1},
                        {"label": "active", "value": 0},
                    ],
                    
                    value=[],
                    id="checklist-idle-input",
                    inline=True,
                ),
                dbc.Label("empty full"),
                dbc.Checklist(
                    options=[
                        {"label": "empty", "value": 1},
                        {"label": "full", "value": 0},
                    ],
                    
                    value=[],
                    id="checklist-emptyfull-input",
                    inline=True,
                ),
                dbc.Label("Max Full Draft (meter)"),
                dcc.Slider(
                    id='fulldraft-slider',
                    min=11,
                    max=14,
                    step=0.2,
                    marks={value: str(value) for value in range(11, 15) if value % 1 == 0},

                    value=12,  # Initial value
                ),  
                
                 # Display the counts of 'Full' and 'Empty' values
                html.Div(id='ef-counts'),
                
                html.Label('Select a Time Range (in hours):'),
                dcc.Slider(
                    id='time-range-slider',
                    min=1,
                    max=81,
                    step=1,
                    marks={i: str(i) for i in range(1, 81, 8)},
                    value=30  # Initial time range value
                ),
                html.Label('idle if no movement in (days)'),
                dcc.Slider(
                    id='idle-slider',
                    min=1,
                    max=8,
                    step=1,
                    marks={i: str(i) for i in range(1, 9, 1)},
                    value=5  # Initial time range value

                )

                 # Display the counts of 'Full' and 'Empty' values
                #html.Div(id='ef-counts')

                          
   
                
                # Output for displaying the filtered data
           
            ]),
            width=3  # Left side column width
        ),
        dbc.Col(
            html.Div([
                dcc.Graph(
                    id='map'
                )
            ]),
            width=8  # Right side column width
        )
    ], justify="left")  # Center-aligns the row
])    
@app.callback(
    Output('source-subregion-dropdown', 'options'),
    [Input('source-region-dropdown', 'value')]
)
def update_subregion_options(selected_regions):
    if 'selectall' in selected_regions:
        filtered_ship_data = ship_data
        selected_regions.remove('selectall')
    elif 'deselectall' in selected_regions:
        filtered_ship_data = pd.DataFrame()  # Empty DataFrame when 'deselectall' is selected
        selected_regions.remove('deselectall')
    else:
        filtered_ship_data = ship_data[ship_data['source_region'].isin(selected_regions)]

    subregions = filtered_ship_data['source_subregion'].unique()
    return [{'label': subregion, 'value': subregion} for subregion in subregions]

@app.callback(
    Output('source-port-dropdown', 'options'),
    [Input('source-subregion-dropdown', 'value')]
)
def update_port_options(selected_subregions):
    filtered_ship_data = ship_data[ship_data['source_subregion'].isin(selected_subregions)]
    ports = filtered_ship_data['source_port'].unique()
    return [{'label': port, 'value': port} for port in ports]



@app.callback(
    Output('dest-subregion-dropdown', 'options'),
    [Input('dest-region-dropdown', 'value')]
)
def update_dest_subregion_options(selected_dest_regions):
    if 'selectall' in selected_dest_regions:
        subregions = combined_data['subregion'].dropna().unique()
        return [{'label': subregion, 'value': subregion} for subregion in subregions]

    elif 'deselectall' in selected_dest_regions:
        return []

    else:
        filtered_combined_data = combined_data[combined_data['region'].isin(selected_dest_regions)]
        subregions = filtered_combined_data['subregion'].dropna().unique()
        return [{'label': subregion, 'value': subregion} for subregion in subregions]


@app.callback(
    Output('dest-port-dropdown', 'options'),
    [Input('dest-subregion-dropdown', 'value')]
)
def update_dest_port_options(selected_dest_subregions):
    if 'selectall' in selected_dest_subregions:
        filtered_combined_data = combined_data
        selected_dest_subregions.remove('selectall')
    elif 'deselectall' in selected_dest_subregions:
        filtered_combined_data = pd.DataFrame()  # Empty DataFrame when 'deselectall' is selected
        selected_dest_subregions.remove('deselectall')
    else:
        filtered_combined_data = combined_data[combined_data['subregion'].isin(selected_dest_subregions)]

    ports = filtered_combined_data['port_name'].dropna().unique()
    return [{'label': port, 'value': port} for port in ports]





@app.callback(
    Output('map', 'figure'),
    Output('ef-counts', 'children'),
    [Input('imo-search', 'value'),
     Input('source-region-dropdown', 'value'),
     Input('source-subregion-dropdown', 'value'),
     Input('source-port-dropdown', 'value'),
     Input('dest-region-dropdown', 'value'),
     Input('dest-subregion-dropdown', 'value'),
     Input('dest-port-dropdown', 'value'),
     Input('checklist-idle-input', 'value'),
     Input('checklist-emptyfull-input', 'value'),
     Input('fulldraft-slider','value'),
     Input('time-range-slider', 'value'),
     Input('idle-slider','value'),
     Input('map', 'relayoutData')
     ]
)
def update_map(imo_number, selected_regions,selected_subregions,selected_ports,dest_regions,dest_subregions,dest_ports,
               selected_idle_status,selected_emptyfull_status,fulldraft,selected_time_range,idle_slider,relayout_data):
    filtered_ship_data = combined_data  # Initialize with the combined data

    #print(combined_data.columns.tolist())
    #print(filtered_ship_data['idle_y'].head())

     # Filter based on selected idle status
    #if selected_idle_status:
    #    filtered_ship_data = combined_data[combined_data['idle'].isin(selected_idle_status)]

    
        
    if idle_slider:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['idle_x'] <= idle_slider]

    
    

    if fulldraft:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['max_draft'] <= fulldraft]

    if selected_emptyfull_status:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['empty_full'].isin(selected_emptyfull_status)]

    if selected_idle_status:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['idle_y'].isin(selected_idle_status)]


    if dest_ports and 'selectall' not in dest_ports:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['port_name'].isin(dest_ports)]


    if dest_regions and 'selectall' not in dest_regions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['region'].isin(dest_regions)]

    if dest_subregions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['subregion'].isin(dest_subregions)]

    # Filter data based on selected regions
    if selected_regions and 'selectall' not in selected_regions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_region'].isin(selected_regions)]

    # Filter data based on sub regions
    if selected_subregions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_subregion'].isin(selected_subregions)]

    # Filter data based on IMO number if provided
    if imo_number and imo_number.isdigit():
        imo_number = int(imo_number)
        filtered_ship_data = filtered_ship_data[filtered_ship_data['imo'] == imo_number]

    if selected_ports:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_port'].isin(selected_ports)]
    
    


    # Convert 'seen_date' column to datetime
    filtered_ship_data['seen_date'] = pd.to_datetime(filtered_ship_data['seen_date'])

    # Group by 'imo' and get the latest 'seen_date' for each IMO
    latest_dates = filtered_ship_data.groupby('imo')['seen_date'].max().reset_index()

    # Merge to get the lat/lon corresponding to the latest 'seen_date'
    latest_locations = pd.merge(latest_dates, filtered_ship_data, on=['imo', 'seen_date'], how='left')

    # Create a column 'hours_since_latest' representing the difference in hours from the latest 'seen_date'
    latest_locations['hours_since_latest'] = (latest_locations['seen_date'].max() - latest_locations['seen_date']).dt.total_seconds() / 3600

    # Create a new column 'size' to differentiate between latest and previous locations
    latest_locations['size'] = 10  # Default size for previous locations
    #latest_locations.loc[latest_locations['hours_since_latest'] == 0, 'size'] = 20  # Larger size for the latest location

    #filtered_ship_data = filtered_ship_data[filtered_ship_data['seen_date_hour'] <= selected_time_range]

    '''if relayout_data and 'mapbox' in relayout_data:
        # Filter based on box selection
        bounds = relayout_data['mapbox']['bounds']

        filtered_ship_data = filtered_ship_data[
            (filtered_ship_data['lat'] >= bounds['south']) &
            (filtered_ship_data['lat'] <= bounds['north']) &
            (filtered_ship_data['lon'] >= bounds['west']) &
            (filtered_ship_data['lon'] <= bounds['east'])
        ]'''

    # Calculate counts of 'Full' and 'Empty' values in the 'ef' column
    full_count = len(latest_locations[latest_locations['ef'] == 0])  # Assuming '0' represents 'Full'
    empty_count = len(latest_locations[latest_locations['ef'] == 1])  # Assuming '1' represents 'Empty'
    total=full_count + empty_count

    yyfull_count = len(latest_locations[latest_locations['empty_full'] == 0])
    yyempty_count = len(latest_locations[latest_locations['empty_full'] == 1])
    yytotal=yyfull_count+yyempty_count
    
    # Create text to display the counts
    ef_counts_text = html.P(f' Full : {full_count}, Empty : {empty_count} ,total :{total}|| '
                        f'y/y - Full : {yyfull_count}, Empty : {yyempty_count},total :{yytotal}')
    #ef_counts_text= html.P(f'Full Count2:{yyfull_count}, Empty Count2: {yyempty_count}')

    
    
    # Get unique regions and assign a unique color to each region
    unique_regions = filtered_ship_data['region'].unique()
    color_map = {
        region: px.colors.qualitative.Set1[i % len(px.colors.qualitative.Set1)]
        for i, region in enumerate(unique_regions)
    }

    traces = []
    #color = 'Same Color'  # Set a common color for all traces

    for imo in filtered_ship_data['imo'].unique():
        imo_df = filtered_ship_data[filtered_ship_data['imo'] == imo]


        customdata_columns = ['imo','region', 'subregion', 'port_name','model_eta', 'name', 'size','draft','max_draft','ef','stated_destination','stated_eta','begin_port_name','begin_region','origin_type','idle_y']  # Columns to include in customdata
    
            # Create hovertemplate dynamically based on columns
        hovertemplate = "<br>".join([f"<b>{col}</b>: %{{customdata[{i}]}}" for i, col in enumerate(customdata_columns)]) + "<extra></extra>"
    
            # Create customdata DataFrame dynamically based on columns
        customdata = pd.DataFrame({col: imo_df[col] for col in customdata_columns})

        end_hour = imo_df['seen_date_hour'].max()
        start_hour = max(end_hour - selected_time_range, 0)

        imo_filtered = imo_df[(imo_df['seen_date_hour'] >= start_hour) & (imo_df['seen_date_hour'] <= end_hour)]
        
        imo_map_trace = go.Scattermapbox(
            mode="lines",
            lon=imo_df['lon'],
            lat=imo_df['lat'],
            marker={'size': 5},
            line=dict(color=color_map.get(imo_df['region'].iloc[0], 'white')),  # Assign color based on 'region'
            name=f'imo={imo}',
            hovertemplate=hovertemplate,
            customdata=customdata,
            showlegend=False
        )
        # Append each Scattermapbox trace to the 'traces' list
        traces.append(imo_map_trace)
    
    # Create a base map using plotly express scatter_mapbox
    imo_map = px.scatter_mapbox(
        latest_locations,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        title=f'IMO and Ports Locations for {selected_regions if selected_regions else "All"}',
        color='region' , # Assuming 'region' column determines color in latest_locations
        color_discrete_map=color_map  # Apply the same color map to ensure consistency
    )

    
    imo_map.update_traces(marker=dict(size=15))
    
    # Update marker sizes for differentiating latest and previous locations
    #imo_map.update_traces(marker=dict(size=latest_locations['size']))
    imo_map.update_layout(mapbox_style="open-street-map", margin={"r": 0, "t": 0, "l": 0, "b": 0})

    # Add the traces to the `imo_map` object
    for trace in traces:
        imo_map.add_trace(trace)
    #imo_map.add_trace(fig_trace)

    # Add ports data to the map
    ports_map = px.scatter_mapbox(
        ports_data,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        text='name',
        title='IMO and Ports Locations'
    )

    ports_map.update_traces(marker=dict(size=10, color='grey',opacity=0.8))

    for data in ports_map.data:
        imo_map.add_trace(data)

    imo_map.update_layout(
        mapbox_style="open-street-map",
        margin={"r": 0, "t": 0, "l": 0, "b": 0}
    )


    return imo_map,ef_counts_text

#fig.show()
if __name__ == '__main__':
    app.run_server(debug=True)

"""
12
#completed all filters
'''
import pandas as pd
import plotly.express as px
import dash
from dash import html, dcc
from dash.dependencies import Input, Output
import dash_bootstrap_components as dbc
import plotly.graph_objects as go



# Read the CSV files for IMO and ports data
ship_data = pd.read_csv("https://dl.dropboxusercontent.com/scl/fi/4bz3qrjqhbevtlqn4w131/imo_tracking.csv?rlkey=w9evtnyx2oo1wwx2sdaw0190r&dl=0")
#ship_data = pd.read_csv("imo_tracking.csv")
ports_data = pd.read_csv("https://dl.dropboxusercontent.com/scl/fi/4h83p47fpaz5v1tnhaw69/ports.csv?rlkey=1erpymfq8eq6fzst5dcxi0wt3&dl=0")
#ports_data = pd.read_csv("ports.csv")
regions = pd.read_csv("https://dl.dropboxusercontent.com/scl/fi/dhow2fvxtibo46gjget76/regions.csv?rlkey=xsoa08k36f2z8q4rqpy4p29y8&dl=0")
#regions = pd.read_csv("regions.csv")
yy_ship_count = pd.read_csv("https://dl.dropboxusercontent.com/scl/fi/gzu9k87fxiutcf0q6uqo3/yy_ship_count.csv?rlkey=04hv0trgaoe0myk3pjcsmnu7e&dl=0")
#yy_ship_count = pd.read_csv("yy_ship_count.csv")
combined_data = pd.merge(ship_data, yy_ship_count, on='imo', how='left')

#combined_data['seen_date'] = pd.to_datetime(combined_data['seen_date'], format='%Y-%m-%d %H:%M:%S')
#combined_data['seen_date_hour'] = combined_data['seen_date'].dt.hour  # Extract hours from seen_date

#df['seen_date_hour'] = df['seen_date'].dt.hour  # Extract hours from seen_date
combined_data['seen_date'] = pd.to_datetime(combined_data['seen_date'], format='%Y-%m-%d %H:%M:%S')
#df['cumulative_hours'] = (df['seen_date'] - df['seen_date'].min()).dt.total_seconds() / 3600 + 1
combined_data['cumulative_hours'] = (combined_data['seen_date'] - combined_data['seen_date'].iloc[0]).dt.total_seconds() / 3600

#latest_locations = ship_data.groupby('imo').apply(lambda x: x.loc[x['seen_date'].idxmax()]).reset_index(drop=True)

#a=combined_data[['seen_date','cumulative_hours','imo','lat','lon']]
#print(a.head(52))

app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Get unique values for the source region dropdown
source_regions = ship_data['source_region'].unique()

app.layout = dbc.Container([
    
    dbc.Row([
        dbc.Col(
            html.Div([
                dcc.Input(
                    id='imo-search',
                    type='text',
                    placeholder='Enter IMO number...',
                    value='',  # Initial value of the search box
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Regions"),
                dcc.Dropdown(
                    id='source-region-dropdown',
                    options=[{'label': 'Select All', 'value': 'selectall'},
                             {'label': 'Deselect All', 'value': 'deselectall'}] + [{'label': region, 'value': region} for region in source_regions],
                    value=['selectall'],  # Set default value as 'selectall'
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Select Sub-regions"),
                dcc.Dropdown(
                    id='source-subregion-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': subregion, 'value': subregion} for subregion in ship_data['source_subregion'].unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Select Ports"),
                dcc.Dropdown(
                    id='source-port-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': port, 'value': port} for port in ship_data['source_port'].unique()],
                    value=[],  # Initial value for port dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                html.Label("Dest Region"),
                dcc.Dropdown(
                    id='dest-region-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] +[{'label': region, 'value': region} for region in regions['region'].unique()],
                    value=[],  # Initial value for region dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),

                html.Label("Dest Sub-region"),
                dcc.Dropdown(
                    id='dest-subregion-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': subregion, 'value': subregion} for subregion in combined_data['subregion'].dropna().unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),

                html.Label("Dest port"),
                dcc.Dropdown(
                    id='dest-port-dropdown',
                    options=[
                        {'label': 'Select All', 'value': 'selectall'},
                        {'label': 'Deselect All', 'value': 'deselectall'}
                    ] + [{'label': port_name, 'value': port_name} for port_name in combined_data['port_name'].dropna().unique()],
                    value=[],  # Initial value for subregion dropdown
                    multi=True,  # Enable multiple selection
                    style={'width': '100%'}  # Adjust width to 100%
                ),
                dbc.Label("Idle Ships"),
                dbc.Checklist(
                    options=[
                        {"label": "idle", "value": 1},
                        {"label": "active", "value": 0},
                    ],
                    
                    value=[],
                    id="checklist-idle-input",
                    inline=True,
                ),
                dbc.Label("empty full"),
                dbc.Checklist(
                    options=[
                        {"label": "empty", "value": 1},
                        {"label": "full", "value": 0},
                    ],
                    
                    value=[],
                    id="checklist-emptyfull-input",
                    inline=True,
                ),
                dbc.Label("Max Full Draft (meter)"),
                dcc.Slider(
                    id='fulldraft-slider',
                    min=11,
                    max=14,
                    step=0.2,
                    marks={value: str(value) for value in range(11, 15) if value % 1 == 0},

                    value=12,  # Initial value
                ),  
                
                 # Display the counts of 'Full' and 'Empty' values
                html.Div(id='ef-counts'),
                
                html.Label('Select a Time Range (in hours):'),
                dcc.Slider(
                    id='time-range-slider',
                    min=1,
                    max=81,
                    step=1,
                    marks={i: str(i) for i in range(1, 81, 8)},
                    value=30  # Initial time range value
                ),
                html.Label('idle if no movement in (days)'),
                dcc.Slider(
                    id='idle-slider',
                    min=1,
                    max=8,
                    step=1,
                    marks={i: str(i) for i in range(1, 9, 1)},
                    value=5  # Initial time range value

                )

                 # Display the counts of 'Full' and 'Empty' values
                #html.Div(id='ef-counts')

                          
   
                
                # Output for displaying the filtered data
           
            ]),
            width=3  # Left side column width
        ),
        dbc.Col(
            html.Div([
                dcc.Graph(
                    id='map'
                )
            ]),
            width=8  # Right side column width
        )
    ], justify="left")  # Center-aligns the row
])  
print("part 1")  
@app.callback(
    Output('source-subregion-dropdown', 'options'),
    [Input('source-region-dropdown', 'value')]
)
def update_subregion_options(selected_regions):
    if 'selectall' in selected_regions:
        filtered_ship_data = ship_data
        selected_regions.remove('selectall')
    elif 'deselectall' in selected_regions:
        filtered_ship_data = pd.DataFrame()  # Empty DataFrame when 'deselectall' is selected
        selected_regions.remove('deselectall')
    else:
        filtered_ship_data = ship_data[ship_data['source_region'].isin(selected_regions)]

    subregions = filtered_ship_data['source_subregion'].unique()
    return [{'label': subregion, 'value': subregion} for subregion in subregions]

@app.callback(
    Output('source-port-dropdown', 'options'),
    [Input('source-subregion-dropdown', 'value')]
)
def update_port_options(selected_subregions):
    filtered_ship_data = ship_data[ship_data['source_subregion'].isin(selected_subregions)]
    ports = filtered_ship_data['source_port'].unique()
    return [{'label': port, 'value': port} for port in ports]



@app.callback(
    Output('dest-subregion-dropdown', 'options'),
    [Input('dest-region-dropdown', 'value')]
)
def update_dest_subregion_options(selected_dest_regions):
    if 'selectall' in selected_dest_regions:
        subregions = combined_data['subregion'].dropna().unique()
        return [{'label': subregion, 'value': subregion} for subregion in subregions]

    elif 'deselectall' in selected_dest_regions:
        return []

    else:
        filtered_combined_data = combined_data[combined_data['region'].isin(selected_dest_regions)]
        subregions = filtered_combined_data['subregion'].dropna().unique()
        return [{'label': subregion, 'value': subregion} for subregion in subregions]


@app.callback(
    Output('dest-port-dropdown', 'options'),
    [Input('dest-subregion-dropdown', 'value')]
)
def update_dest_port_options(selected_dest_subregions):
    if 'selectall' in selected_dest_subregions:
        filtered_combined_data = combined_data
        selected_dest_subregions.remove('selectall')
    elif 'deselectall' in selected_dest_subregions:
        filtered_combined_data = pd.DataFrame()  # Empty DataFrame when 'deselectall' is selected
        selected_dest_subregions.remove('deselectall')
    else:
        filtered_combined_data = combined_data[combined_data['subregion'].isin(selected_dest_subregions)]

    ports = filtered_combined_data['port_name'].dropna().unique()
    return [{'label': port, 'value': port} for port in ports]



print("part 2")

@app.callback(
    Output('map', 'figure'),
    Output('ef-counts', 'children'),
    [Input('imo-search', 'value'),
     Input('source-region-dropdown', 'value'),
     Input('source-subregion-dropdown', 'value'),
     Input('source-port-dropdown', 'value'),
     Input('dest-region-dropdown', 'value'),
     Input('dest-subregion-dropdown', 'value'),
     Input('dest-port-dropdown', 'value'),
     Input('checklist-idle-input', 'value'),
     Input('checklist-emptyfull-input', 'value'),
     Input('fulldraft-slider','value'),
     Input('time-range-slider', 'value'),
     Input('idle-slider','value'),
     
     ]
)

def update_map(imo_number, selected_regions,selected_subregions,selected_ports,dest_regions,dest_subregions,dest_ports,
               selected_idle_status,selected_emptyfull_status,fulldraft,selected_time_range,idle_slider):
    filtered_ship_data = combined_data  # Initialize with the combined data

    #print(combined_data.columns.tolist())
    #print(filtered_ship_data['idle_y'].head())

     # Filter based on selected idle status
    #if selected_idle_status:
    #    filtered_ship_data = combined_data[combined_data['idle'].isin(selected_idle_status)]

    

    print("part 3")
        
    if idle_slider:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['idle_x'] <= idle_slider]

    
    

    if fulldraft:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['max_draft'] <= fulldraft]

    if selected_emptyfull_status:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['empty_full'].isin(selected_emptyfull_status)]

    if selected_idle_status:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['idle_y'].isin(selected_idle_status)]


    if dest_ports and 'selectall' not in dest_ports:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['port_name'].isin(dest_ports)]


    if dest_regions and 'selectall' not in dest_regions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['region'].isin(dest_regions)]

    if dest_subregions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['subregion'].isin(dest_subregions)]

    # Filter data based on selected regions
    if selected_regions and 'selectall' not in selected_regions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_region'].isin(selected_regions)]

    # Filter data based on sub regions
    if selected_subregions:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_subregion'].isin(selected_subregions)]

    # Filter data based on IMO number if provided
    if imo_number and imo_number.isdigit():
        imo_number = int(imo_number)
        filtered_ship_data = filtered_ship_data[filtered_ship_data['imo'] == imo_number]

    if selected_ports:
        filtered_ship_data = filtered_ship_data[filtered_ship_data['source_port'].isin(selected_ports)]
    
    
    print ("part 4")

    # Convert 'seen_date' column to datetime
    filtered_ship_data['seen_date'] = pd.to_datetime(filtered_ship_data['seen_date'])

    # Group by 'imo' and get the latest 'seen_date' for each IMO
    latest_dates = filtered_ship_data.groupby('imo')['seen_date'].max().reset_index()

    # Merge to get the lat/lon corresponding to the latest 'seen_date'
    latest_locations = pd.merge(latest_dates, filtered_ship_data, on=['imo', 'seen_date'], how='left')

    # Create a column 'hours_since_latest' representing the difference in hours from the latest 'seen_date'
    latest_locations['hours_since_latest'] = (latest_locations['seen_date'].max() - latest_locations['seen_date']).dt.total_seconds() / 3600

    # Create a new column 'size' to differentiate between latest and previous locations
    latest_locations['size'] = 10  # Default size for previous locations
    #latest_locations.loc[latest_locations['hours_since_latest'] == 0, 'size'] = 20  # Larger size for the latest location

    #filtered_ship_data = filtered_ship_data[filtered_ship_data['seen_date_hour'] <= selected_time_range]
    print("part 5")

    # Calculate counts of 'Full' and 'Empty' values in the 'ef' column
    full_count = len(latest_locations[latest_locations['ef'] == 0])  # Assuming '0' represents 'Full'
    empty_count = len(latest_locations[latest_locations['ef'] == 1])  # Assuming '1' represents 'Empty'
    total=full_count + empty_count

    yyfull_count = len(latest_locations[latest_locations['empty_full'] == 0])
    yyempty_count = len(latest_locations[latest_locations['empty_full'] == 1])
    yytotal=yyfull_count+yyempty_count
    
    # Create text to display the counts
    ef_counts_text = html.P(f' Full : {full_count}, Empty : {empty_count} ,total :{total}|| '
                        f'y/y - Full : {yyfull_count}, Empty : {yyempty_count},total :{yytotal}')
    #ef_counts_text= html.P(f'Full Count2:{yyfull_count}, Empty Count2: {yyempty_count}')

    print("part 6")
    
    # Get unique regions and assign a unique color to each region
    unique_regions = filtered_ship_data['region'].unique()
    color_map = {
        region: px.colors.qualitative.Set1[i % len(px.colors.qualitative.Set1)]
        for i, region in enumerate(unique_regions)
    }

    traces = []
    #color = 'Same Color'  # Set a common color for all traces
    print("part 7")
    for imo in filtered_ship_data['imo'].unique():
        imo_df = filtered_ship_data[filtered_ship_data['imo'] == imo]
        print("part 7.1")

        latest_time = filtered_ship_data['cumulative_hours'].max()
        start_hour = max(latest_time - selected_time_range, 0)
        print("part 7.2")

        imo_filtered = imo_df[(imo_df['cumulative_hours'] >= start_hour) & (imo_df['cumulative_hours'] <= latest_time)]

        print("part 8")

        customdata_columns = ['imo','region', 'subregion', 'port_name','model_eta', 'name', 'size','draft','max_draft','ef','stated_destination','stated_eta','begin_port_name','begin_region','origin_type','idle_y']  # Columns to include in customdata
    
            # Create hovertemplate dynamically based on columns
        hovertemplate = "<br>".join([f"<b>{col}</b>: %{{customdata[{i}]}}" for i, col in enumerate(customdata_columns)]) + "<extra></extra>"
    
            # Create customdata DataFrame dynamically based on columns
        customdata = pd.DataFrame({col: imo_df[col] for col in customdata_columns})

        #end_hour = imo_df['seen_date_hour'].max()
        #start_hour = max(end_hour - selected_time_range, 0)

        #imo_filtered = imo_df[(imo_df['seen_date_hour'] >= start_hour) & (imo_df['seen_date_hour'] <= end_hour)]

        print("part 9")
        
        imo_map_trace = go.Scattermapbox(
            mode="lines",
            lon=imo_filtered['lon'],
            lat=imo_filtered['lat'],
            marker={'size': 5},
            line=dict(color=color_map.get(imo_df['region'].iloc[0], 'white')),  # Assign color based on 'region'
            name=f'imo={imo}',
            hovertemplate=hovertemplate,
            customdata=customdata,
            showlegend=False
        )
        # Append each Scattermapbox trace to the 'traces' list
        traces.append(imo_map_trace)
    print("part 10")
    # Create a base map using plotly express scatter_mapbox
    imo_map = px.scatter_mapbox(
        latest_locations,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        title=f'IMO and Ports Locations for {selected_regions if selected_regions else "All"}',
        color='region' , # Assuming 'region' column determines color in latest_locations
        color_discrete_map=color_map  # Apply the same color map to ensure consistency
    )

    
    imo_map.update_traces(marker=dict(size=15))

    print("part 11")
    
    # Update marker sizes for differentiating latest and previous locations
    #imo_map.update_traces(marker=dict(size=latest_locations['size']))
    imo_map.update_layout(mapbox_style="open-street-map", margin={"r": 0, "t": 0, "l": 0, "b": 0})

    # Add the traces to the `imo_map` object
    for trace in traces:
        imo_map.add_trace(trace)
    #imo_map.add_trace(fig_trace)

    # Add ports data to the map
    ports_map = px.scatter_mapbox(
        ports_data,
        lat='lat',
        lon='lon',
        zoom=2,
        width=1000,
        height=600,
        text='name',
        title='IMO and Ports Locations'
    )

    print("part 12")

    ports_map.update_traces(marker=dict(size=10, color='grey',opacity=0.8))

    for data in ports_map.data:
        imo_map.add_trace(data)

    imo_map.update_layout(
        mapbox_style="open-street-map",
        margin={"r": 0, "t": 0, "l": 0, "b": 0}
    )
    print("part 13")

    return imo_map,ef_counts_text

#fig.show()
if __name__ == '__main__':
    app.run_server(debug=True)


'''
